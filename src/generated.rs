// Auto generated by codegen/src/api.rs

#[allow(unused_imports)]
use crate::extra::{Base64Options, LastChunkHandlingOptions, Result};

#[cfg(feature = "ascii")]
/// Validate the ASCII string.
///
/// Returns [`true`] if and only if the string is valid ASCII.
#[inline]
#[must_use]
pub fn validate_ascii(src: &[u8]) -> bool {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_validate_ascii(buf, len) }
}

#[cfg(feature = "utf8")]
/// Validate the UTF-8 string.
///
/// Returns [`true`] if and only if the string is valid UTF-8.
#[inline]
#[must_use]
pub fn validate_utf8(src: &[u8]) -> bool {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_validate_utf8(buf, len) }
}

#[cfg(feature = "utf16")]
/// Validate the UTF-16 string.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// Returns [`true`] if and only if the string is valid UTF-16.
#[inline]
#[must_use]
pub fn validate_utf16(src: &[u16]) -> bool {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_validate_utf16(buf, len) }
}

#[cfg(feature = "utf16")]
/// Validate the UTF-16BE string.
///
/// This function is not BOM-aware.
///
/// Returns [`true`] if and only if the string is valid UTF-16BE.
#[inline]
#[must_use]
pub fn validate_utf16be(src: &[u16]) -> bool {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_validate_utf16be(buf, len) }
}

#[cfg(feature = "utf16")]
/// Validate the UTF-16LE string.
///
/// This function is not BOM-aware.
///
/// Returns [`true`] if and only if the string is valid UTF-16LE.
#[inline]
#[must_use]
pub fn validate_utf16le(src: &[u16]) -> bool {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_validate_utf16le(buf, len) }
}

#[cfg(feature = "utf32")]
/// Validate the UTF-32 string.
///
/// This function uses native endianness.
///
/// Returns [`true`] if and only if the string is valid UTF-32.
#[inline]
#[must_use]
pub fn validate_utf32(src: &[u32]) -> bool {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_validate_utf32(buf, len) }
}

#[cfg(feature = "ascii")]
/// Validate the ASCII string.
///
#[inline]
#[must_use]
pub fn validate_ascii_with_errors(src: &[u8]) -> Result {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_validate_ascii_with_errors(buf, len) }
}

#[cfg(feature = "utf8")]
/// Validate the UTF-8 string.
///
#[inline]
#[must_use]
pub fn validate_utf8_with_errors(src: &[u8]) -> Result {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_validate_utf8_with_errors(buf, len) }
}

#[cfg(feature = "utf16")]
/// Validate the UTF-16 string.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
#[inline]
#[must_use]
pub fn validate_utf16_with_errors(src: &[u16]) -> Result {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_validate_utf16_with_errors(buf, len) }
}

#[cfg(feature = "utf16")]
/// Validate the UTF-16BE string.
///
/// This function is not BOM-aware.
///
#[inline]
#[must_use]
pub fn validate_utf16be_with_errors(src: &[u16]) -> Result {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_validate_utf16be_with_errors(buf, len) }
}

#[cfg(feature = "utf16")]
/// Validate the UTF-16LE string.
///
/// This function is not BOM-aware.
///
#[inline]
#[must_use]
pub fn validate_utf16le_with_errors(src: &[u16]) -> Result {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_validate_utf16le_with_errors(buf, len) }
}

#[cfg(feature = "utf32")]
/// Validate the UTF-32 string.
///
/// This function uses native endianness.
///
#[inline]
#[must_use]
pub fn validate_utf32_with_errors(src: &[u32]) -> Result {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_validate_utf32_with_errors(buf, len) }
}

#[cfg(feature = "utf8")]
/// Count the number of code points in the UTF-8 string.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-8 strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn count_utf8(src: &[u8]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_count_utf8(buf, len) }
}

#[cfg(feature = "utf16")]
/// Count the number of code points in the UTF-16 string.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-16 strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn count_utf16(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_count_utf16(buf, len) }
}

#[cfg(feature = "utf16")]
/// Count the number of code points in the UTF-16BE string.
///
/// This function is not BOM-aware.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-16BE strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn count_utf16be(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_count_utf16be(buf, len) }
}

#[cfg(feature = "utf16")]
/// Count the number of code points in the UTF-16LE string.
///
/// This function is not BOM-aware.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-16LE strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn count_utf16le(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_count_utf16le(buf, len) }
}

#[cfg(feature = "utf8")]
/// Given a valid UTF-8 string having a possibly truncated last character,
/// this function checks the end of string. If the last character is truncated
/// (or partial), then it returns a shorter length so that the short UTF-8
/// string only contains complete characters. If there is no truncated character,
/// the original length is returned.
///
/// This function assumes that the input string is valid UTF-8, but possibly truncated.
///
#[inline]
#[must_use]
pub fn trim_partial_utf8(src: &[u8]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_trim_partial_utf8(buf, len) }
}

#[cfg(feature = "utf16")]
/// Given a valid UTF-16 string having a possibly truncated last character,
/// this function checks the end of string. If the last character is truncated
/// (or partial), then it returns a shorter length so that the short UTF-16
/// string only contains complete characters. If there is no truncated character,
/// the original length is returned.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// This function assumes that the input string is valid UTF-16, but possibly truncated.
///
#[inline]
#[must_use]
pub fn trim_partial_utf16(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_trim_partial_utf16(buf, len) }
}

#[cfg(feature = "utf16")]
/// Given a valid UTF-16BE string having a possibly truncated last character,
/// this function checks the end of string. If the last character is truncated
/// (or partial), then it returns a shorter length so that the short UTF-16BE
/// string only contains complete characters. If there is no truncated character,
/// the original length is returned.
///
/// This function is not BOM-aware.
///
/// This function assumes that the input string is valid UTF-16BE, but possibly truncated.
///
#[inline]
#[must_use]
pub fn trim_partial_utf16be(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_trim_partial_utf16be(buf, len) }
}

#[cfg(feature = "utf16")]
/// Given a valid UTF-16LE string having a possibly truncated last character,
/// this function checks the end of string. If the last character is truncated
/// (or partial), then it returns a shorter length so that the short UTF-16LE
/// string only contains complete characters. If there is no truncated character,
/// the original length is returned.
///
/// This function is not BOM-aware.
///
/// This function assumes that the input string is valid UTF-16LE, but possibly truncated.
///
#[inline]
#[must_use]
pub fn trim_partial_utf16le(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_trim_partial_utf16le(buf, len) }
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Count the number of code units that the UTF-16 string would require in UTF-8 format.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-16 strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn utf8_length_from_utf16(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_utf8_length_from_utf16(buf, len) }
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Count the number of code units that the UTF-16BE string would require in UTF-8 format.
///
/// This function is not BOM-aware.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-16BE strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn utf8_length_from_utf16be(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_utf8_length_from_utf16be(buf, len) }
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Count the number of code units that the UTF-16LE string would require in UTF-8 format.
///
/// This function is not BOM-aware.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-16LE strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn utf8_length_from_utf16le(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_utf8_length_from_utf16le(buf, len) }
}

#[cfg(all(feature = "utf8", feature = "utf32"))]
/// Count the number of code units that the UTF-32 string would require in UTF-8 format.
///
/// This function uses native endianness.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-32 strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn utf8_length_from_utf32(src: &[u32]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_utf8_length_from_utf32(buf, len) }
}

#[cfg(all(feature = "utf8", feature = "latin1"))]
/// Count the number of code units that the Latin1 string would require in UTF-8 format.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid Latin1 strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn utf8_length_from_latin1(src: &[u8]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_utf8_length_from_latin1(buf, len) }
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Count the number of code units that the UTF-8 string would require in UTF-16 format.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-8 strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn utf16_length_from_utf8(src: &[u8]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_utf16_length_from_utf8(buf, len) }
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Count the number of code units that the UTF-32 string would require in UTF-16 format.
///
/// This function uses native endianness.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-32 strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn utf16_length_from_utf32(src: &[u32]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_utf16_length_from_utf32(buf, len) }
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Count the number of code units that the Latin1 string would require in UTF-16 format.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid Latin1 strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn utf16_length_from_latin1(src_len: usize) -> usize {
    unsafe { crate::bindings::simdutfrs_utf16_length_from_latin1(src_len) }
}

#[cfg(all(feature = "utf8", feature = "utf32"))]
/// Count the number of code units that the UTF-8 string would require in UTF-32 format.
///
/// This function is equivalent to [`count_utf8`].
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-8 strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn utf32_length_from_utf8(src: &[u8]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_utf32_length_from_utf8(buf, len) }
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Count the number of code units that the UTF-16 string would require in UTF-32 format.
///
/// This function is equivalent to [`count_utf16`].
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-16 strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn utf32_length_from_utf16(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_utf32_length_from_utf16(buf, len) }
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Count the number of code units that the UTF-16BE string would require in UTF-32 format.
///
/// This function is equivalent to [`count_utf16be`].
///
/// This function is not BOM-aware.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-16BE strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn utf32_length_from_utf16be(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_utf32_length_from_utf16be(buf, len) }
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Count the number of code units that the UTF-16LE string would require in UTF-32 format.
///
/// This function is equivalent to [`count_utf16le`].
///
/// This function is not BOM-aware.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-16LE strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn utf32_length_from_utf16le(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_utf32_length_from_utf16le(buf, len) }
}

#[cfg(all(feature = "utf8", feature = "latin1"))]
/// Count the number of code units that the UTF-8 string would require in Latin1 format.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-8 strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn latin1_length_from_utf8(src: &[u8]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutfrs_latin1_length_from_utf8(buf, len) }
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Count the number of code units that the UTF-16 string would require in Latin1 format.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-16 strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn latin1_length_from_utf16(src_len: usize) -> usize {
    unsafe { crate::bindings::simdutfrs_latin1_length_from_utf16(src_len) }
}

#[cfg(all(feature = "utf32", feature = "latin1"))]
/// Count the number of code units that the UTF-32 string would require in Latin1 format.
///
/// This function uses native endianness.
///
/// This function does not validate the input.
/// It is acceptable to pass invalid UTF-32 strings but in such cases the result is implementation defined.
///
#[inline]
#[must_use]
pub fn latin1_length_from_utf32(src_len: usize) -> usize {
    unsafe { crate::bindings::simdutfrs_latin1_length_from_utf32(src_len) }
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert possibly broken UTF-8 string into UTF-16 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-8 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf16(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_utf8_to_utf16(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert possibly broken UTF-8 string into UTF-16BE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-8 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf16be(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_utf8_to_utf16be(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert possibly broken UTF-8 string into UTF-16LE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-8 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf16le(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_utf8_to_utf16le(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf32"))]
/// Convert possibly broken UTF-8 string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-8 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf32(src: *const u8, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutfrs_convert_utf8_to_utf32(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "latin1"))]
/// Convert possibly broken UTF-8 string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-8 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_latin1(src: *const u8, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_utf8_to_latin1(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert possibly broken UTF-16 string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16 string
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16_to_utf8(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_utf16_to_utf8(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert possibly broken UTF-16 string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16 string
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16_to_utf32(src: *const u16, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutfrs_convert_utf16_to_utf32(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Convert possibly broken UTF-16 string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16 string
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16_to_latin1(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_utf16_to_latin1(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert possibly broken UTF-16BE string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16BE string
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16be_to_utf8(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_utf16be_to_utf8(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert possibly broken UTF-16BE string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16BE string
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16be_to_utf32(src: *const u16, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutfrs_convert_utf16be_to_utf32(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Convert possibly broken UTF-16BE string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16BE string
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16be_to_latin1(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_utf16be_to_latin1(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert possibly broken UTF-16LE string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16LE string
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16le_to_utf8(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_utf16le_to_utf8(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert possibly broken UTF-16LE string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16LE string
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16le_to_utf32(src: *const u16, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutfrs_convert_utf16le_to_utf32(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Convert possibly broken UTF-16LE string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16LE string
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16le_to_latin1(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_utf16le_to_latin1(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf32"))]
/// Convert possibly broken UTF-32 string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-32 string
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf8(src: *const u32, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_utf32_to_utf8(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert possibly broken UTF-32 string into UTF-16 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-32 string
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf16(src: *const u32, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_utf32_to_utf16(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert possibly broken UTF-32 string into UTF-16BE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-32 string
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf16be(src: *const u32, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_utf32_to_utf16be(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert possibly broken UTF-32 string into UTF-16LE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-32 string
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf16le(src: *const u32, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_utf32_to_utf16le(src, len, dst)
}

#[cfg(all(feature = "utf32", feature = "latin1"))]
/// Convert possibly broken UTF-32 string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-32 string
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_latin1(src: *const u32, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_utf32_to_latin1(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "latin1"))]
/// Convert possibly broken Latin1 string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid Latin1 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_latin1_to_utf8(src: *const u8, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_latin1_to_utf8(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Convert possibly broken Latin1 string into UTF-16 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid Latin1 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_latin1_to_utf16(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_latin1_to_utf16(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Convert possibly broken Latin1 string into UTF-16BE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid Latin1 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_latin1_to_utf16be(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_latin1_to_utf16be(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Convert possibly broken Latin1 string into UTF-16LE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid Latin1 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_latin1_to_utf16le(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_latin1_to_utf16le(src, len, dst)
}

#[cfg(all(feature = "utf32", feature = "latin1"))]
/// Convert possibly broken Latin1 string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid Latin1 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_latin1_to_utf32(src: *const u8, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutfrs_convert_latin1_to_utf32(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert possibly broken UTF-8 string into UTF-16 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf16_with_errors(src: *const u8, len: usize, dst: *mut u16) -> Result {
    crate::bindings::simdutfrs_convert_utf8_to_utf16_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert possibly broken UTF-8 string into UTF-16BE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf16be_with_errors(src: *const u8, len: usize, dst: *mut u16) -> Result {
    crate::bindings::simdutfrs_convert_utf8_to_utf16be_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert possibly broken UTF-8 string into UTF-16LE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf16le_with_errors(src: *const u8, len: usize, dst: *mut u16) -> Result {
    crate::bindings::simdutfrs_convert_utf8_to_utf16le_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf32"))]
/// Convert possibly broken UTF-8 string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf32_with_errors(src: *const u8, len: usize, dst: *mut u32) -> Result {
    crate::bindings::simdutfrs_convert_utf8_to_utf32_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "latin1"))]
/// Convert possibly broken UTF-8 string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_latin1_with_errors(src: *const u8, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutfrs_convert_utf8_to_latin1_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert possibly broken UTF-16 string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16_to_utf8_with_errors(src: *const u16, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutfrs_convert_utf16_to_utf8_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert possibly broken UTF-16 string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16_to_utf32_with_errors(src: *const u16, len: usize, dst: *mut u32) -> Result {
    crate::bindings::simdutfrs_convert_utf16_to_utf32_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Convert possibly broken UTF-16 string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16_to_latin1_with_errors(src: *const u16, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutfrs_convert_utf16_to_latin1_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert possibly broken UTF-16BE string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16be_to_utf8_with_errors(src: *const u16, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutfrs_convert_utf16be_to_utf8_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert possibly broken UTF-16BE string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16be_to_utf32_with_errors(src: *const u16, len: usize, dst: *mut u32) -> Result {
    crate::bindings::simdutfrs_convert_utf16be_to_utf32_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Convert possibly broken UTF-16BE string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16be_to_latin1_with_errors(src: *const u16, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutfrs_convert_utf16be_to_latin1_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert possibly broken UTF-16LE string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16le_to_utf8_with_errors(src: *const u16, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutfrs_convert_utf16le_to_utf8_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert possibly broken UTF-16LE string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16le_to_utf32_with_errors(src: *const u16, len: usize, dst: *mut u32) -> Result {
    crate::bindings::simdutfrs_convert_utf16le_to_utf32_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Convert possibly broken UTF-16LE string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16le_to_latin1_with_errors(src: *const u16, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutfrs_convert_utf16le_to_latin1_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf32"))]
/// Convert possibly broken UTF-32 string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf8_with_errors(src: *const u32, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutfrs_convert_utf32_to_utf8_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert possibly broken UTF-32 string into UTF-16 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf16_with_errors(src: *const u32, len: usize, dst: *mut u16) -> Result {
    crate::bindings::simdutfrs_convert_utf32_to_utf16_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert possibly broken UTF-32 string into UTF-16BE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf16be_with_errors(src: *const u32, len: usize, dst: *mut u16) -> Result {
    crate::bindings::simdutfrs_convert_utf32_to_utf16be_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert possibly broken UTF-32 string into UTF-16LE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf16le_with_errors(src: *const u32, len: usize, dst: *mut u16) -> Result {
    crate::bindings::simdutfrs_convert_utf32_to_utf16le_with_errors(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert valid UTF-8 string into UTF-16 string.
///
/// Returns the number of written code units.
///
/// # Safety
/// + The input string must be valid UTF-8.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf8_to_utf16(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf8_to_utf16(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert valid UTF-8 string into UTF-16BE string.
///
/// Returns the number of written code units.
///
/// # Safety
/// + The input string must be valid UTF-8.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf8_to_utf16be(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf8_to_utf16be(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert valid UTF-8 string into UTF-16LE string.
///
/// Returns the number of written code units.
///
/// # Safety
/// + The input string must be valid UTF-8.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf8_to_utf16le(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf8_to_utf16le(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf32"))]
/// Convert valid UTF-8 string into UTF-32 string.
///
/// Returns the number of written code units.
///
/// # Safety
/// + The input string must be valid UTF-8.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf8_to_utf32(src: *const u8, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf8_to_utf32(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "latin1"))]
/// Convert valid UTF-8 string into Latin1 string.
///
/// Returns the number of written code units.
///
/// # Safety
/// + The input string must be valid UTF-8.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf8_to_latin1(src: *const u8, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf8_to_latin1(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert valid UTF-16 string into UTF-8 string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16_to_utf8(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf16_to_utf8(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert valid UTF-16 string into UTF-32 string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16_to_utf32(src: *const u16, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf16_to_utf32(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Convert valid UTF-16 string into Latin1 string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16_to_latin1(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf16_to_latin1(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert valid UTF-16BE string into UTF-8 string.
///
/// Returns the number of written code units.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16BE.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16be_to_utf8(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf16be_to_utf8(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert valid UTF-16BE string into UTF-32 string.
///
/// Returns the number of written code units.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16BE.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16be_to_utf32(src: *const u16, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf16be_to_utf32(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Convert valid UTF-16BE string into Latin1 string.
///
/// Returns the number of written code units.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16BE.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16be_to_latin1(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf16be_to_latin1(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf16"))]
/// Convert valid UTF-16LE string into UTF-8 string.
///
/// Returns the number of written code units.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16LE.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16le_to_utf8(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf16le_to_utf8(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert valid UTF-16LE string into UTF-32 string.
///
/// Returns the number of written code units.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16LE.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16le_to_utf32(src: *const u16, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf16le_to_utf32(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "latin1"))]
/// Convert valid UTF-16LE string into Latin1 string.
///
/// Returns the number of written code units.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16LE.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16le_to_latin1(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf16le_to_latin1(src, len, dst)
}

#[cfg(all(feature = "utf8", feature = "utf32"))]
/// Convert valid UTF-32 string into UTF-8 string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// # Safety
/// + The input string must be valid UTF-32.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf32_to_utf8(src: *const u32, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf32_to_utf8(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert valid UTF-32 string into UTF-16 string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// # Safety
/// + The input string must be valid UTF-32.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf32_to_utf16(src: *const u32, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf32_to_utf16(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert valid UTF-32 string into UTF-16BE string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// # Safety
/// + The input string must be valid UTF-32.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf32_to_utf16be(src: *const u32, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf32_to_utf16be(src, len, dst)
}

#[cfg(all(feature = "utf16", feature = "utf32"))]
/// Convert valid UTF-32 string into UTF-16LE string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// # Safety
/// + The input string must be valid UTF-32.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf32_to_utf16le(src: *const u32, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutfrs_convert_valid_utf32_to_utf16le(src, len, dst)
}

#[cfg(feature = "base64")]
/// Provide the maximal binary length in bytes given the base64 input.
/// As long as the input does not contain ignorable characters (e.g., ASCII
/// spaces or linefeed characters), the result is exact. In particular, the
/// function checks for padding characters.
///
/// The function is fast (constant time). It checks up to two characters at
/// the end of the string. The input is not otherwise validated or read.
///
/// # Safety
/// + `input` must be non-null and properly aligned.
/// + `input` must be valid for reads of `len * size_of::<u8>()` bytes.
#[inline]
#[must_use]
pub unsafe fn maximal_binary_length_from_base64(input: *const u8, len: usize) -> usize {
    crate::bindings::simdutfrs_maximal_binary_length_from_base64(input, len)
}

#[cfg(feature = "base64")]
/// Provide the maximal binary length in bytes given the base64 input.
/// As long as the input does not contain ignorable characters (e.g., ASCII
/// spaces or linefeed characters), the result is exact. In particular, the
/// function checks for padding characters.
///
/// The function is fast (constant time). It checks up to two characters at
/// the end of the string. The input is not otherwise validated or read.
///
/// # Safety
/// + `input` must be non-null and properly aligned.
/// + `input` must be valid for reads of `len * size_of::<u16>()` bytes.
#[inline]
#[must_use]
pub unsafe fn maximal_binary_length_from_base64_utf16(input: *const u16, len: usize) -> usize {
    crate::bindings::simdutfrs_maximal_binary_length_from_base64_utf16(input, len)
}

#[cfg(feature = "base64")]
/// Convert a base64 input to a binary output.
///
/// This function follows the WHATWG forgiving-base64 format, which means that it
/// will ignore any ASCII spaces in the input. You may provide a padded input
/// (with one or two equal signs at the end) or an unpadded input (without any
/// equal signs at the end).
///
/// See https://infra.spec.whatwg.org/#forgiving-base64-decode
///
/// This function will fail in case of invalid input. When last_chunk_options =
/// loose, there are two possible reasons for failure: the input contains a
/// number of base64 characters that when divided by 4, leaves a single remainder
/// character (BASE64_INPUT_REMAINDER), or the input contains a character that is
/// not a valid base64 character (INVALID_BASE64_CHARACTER).
///
/// When the error is INVALID_BASE64_CHARACTER, the count contains the index in the
/// input where the invalid character was found. When the error is
/// BASE64_INPUT_REMAINDER, then the count contains the number of bytes decoded.
///
/// The default option (Base64Options::Default) expects the characters `+` and
/// `/` as part of its alphabet. The URL option (Base64Options::Url) expects the
/// characters `-` and `_` as part of its alphabet.
///
/// The padding (`=`) is validated if present. There may be at most two padding
/// characters at the end of the input. If there are any padding characters, the
/// total number of characters (excluding spaces but including padding
/// characters) must be divisible by four.
///
/// You should call this function with a buffer that is at least
/// maximal_binary_length_from_base64(input, len) bytes long. If you fail to
/// provide that much space, the function may cause a buffer overflow.
///
/// Advanced users may want to tailor how the last chunk is handled. By default,
/// we use a loose (forgiving) approach but we also support a strict approach
/// as well as a stop_before_partial approach, as per the following proposal:
///
/// https://tc39.es/proposal-arraybuffer-base64/spec/#sec-frombase64
///
/// # Safety
/// + `input` and `output` must be non-null and properly aligned.
/// + `input` must be valid for reads of `len * size_of::<u8>()` bytes.
/// + `output` must be valid for writes of `maximal_binary_length_from_base64(input, len)` bytes.
/// + The memory regions of `input` and `output` must not overlap.
#[inline]
#[must_use]
pub unsafe fn base64_to_binary(
    input: *const u8,
    len: usize,
    output: *mut u8,
    options: Base64Options,
    last_chunk_options: LastChunkHandlingOptions,
) -> Result {
    crate::bindings::simdutfrs_base64_to_binary(input, len, output, options as u64, last_chunk_options as u64)
}

#[cfg(feature = "base64")]
/// Provide the base64 length in bytes given the length of a binary input.
///
/// The length of the output is the length of the input times 4/3. The output
/// buffer should be at least base64_length_from_binary(len) bytes long.
///
/// The default option (Base64Options::Default) uses the characters `+` and `/`
/// as part of its alphabet. Further, it adds padding (`=`) at the end of the
/// output to ensure that the output length is a multiple of four.
///
/// The URL option (Base64Options::Url) uses the characters `-` and `_` as part
/// of its alphabet. No padding is added at the end of the output.
#[inline]
#[must_use]
pub fn base64_length_from_binary(len: usize, options: Base64Options) -> usize {
    unsafe { crate::bindings::simdutfrs_base64_length_from_binary(len, options as u64) }
}

#[cfg(feature = "base64")]
/// Provide the base64 length in bytes given the length of a binary input,
/// taking into account line breaks.
///
/// The length of the output is the length of the input times 4/3. The output
/// buffer should be at least base64_length_from_binary_with_lines(len, options,
/// line_length) bytes long.
///
/// The default option (Base64Options::Default) uses the characters `+` and `/`
/// as part of its alphabet. Further, it adds padding (`=`) at the end of the
/// output to ensure that the output length is a multiple of four.
///
/// The URL option (Base64Options::Url) uses the characters `-` and `_` as part
/// of its alphabet. No padding is added at the end of the output.
///
/// # Arguments
/// * `line_length` - the length of lines, must be at least 4 (otherwise it is
///   interpreted as 4).
#[inline]
#[must_use]
pub fn base64_length_from_binary_with_lines(len: usize, options: Base64Options, line_length: usize) -> usize {
    unsafe { crate::bindings::simdutfrs_base64_length_from_binary_with_lines(len, options as u64, line_length) }
}

#[cfg(feature = "base64")]
/// Convert a binary input to a base64 output.
///
/// The default option (Base64Options::Default) uses the characters `+` and `/`
/// as part of its alphabet. Further, it adds padding (`=`) at the end of the
/// output to ensure that the output length is a multiple of four.
///
/// The URL option (Base64Options::Url) uses the characters `-` and `_` as part
/// of its alphabet. No padding is added at the end of the output.
///
/// This function always succeeds.
///
/// # Safety
/// + `input` and `output` must be non-null and properly aligned.
/// + `input` must be valid for reads of `len * size_of::<u8>()` bytes.
/// + `output` must be valid for writes of `base64_length_from_binary(len, options)` bytes.
/// + The memory regions of `input` and `output` must not overlap.
/// + The returned value is the number of written bytes, will be equal to
///   `base64_length_from_binary(len, options)`.
#[inline]
#[must_use]
pub unsafe fn binary_to_base64(input: *const u8, len: usize, output: *mut u8, options: Base64Options) -> usize {
    crate::bindings::simdutfrs_binary_to_base64(input, len, output, options as u64)
}

#[cfg(feature = "base64")]
/// Convert a binary input to a base64 output with line breaks.
///
/// The default option (Base64Options::Default) uses the characters `+` and `/`
/// as part of its alphabet. Further, it adds padding (`=`) at the end of the
/// output to ensure that the output length is a multiple of four.
///
/// The URL option (Base64Options::Url) uses the characters `-` and `_` as part
/// of its alphabet. No padding is added at the end of the output.
///
/// This function always succeeds.
///
/// # Safety
/// + `input` and `output` must be non-null and properly aligned.
/// + `input` must be valid for reads of `len * size_of::<u8>()` bytes.
/// + `output` must be valid for writes of `base64_length_from_binary_with_lines(len, options, line_length)` bytes.
/// + The memory regions of `input` and `output` must not overlap.
/// + The returned value is the number of written bytes, will be equal to
///   `base64_length_from_binary_with_lines(len, options, line_length)`.
///
/// # Arguments
/// * `line_length` - the length of lines, must be at least 4 (otherwise it is
///   interpreted as 4).
#[inline]
#[must_use]
pub unsafe fn binary_to_base64_with_lines(
    input: *const u8,
    len: usize,
    output: *mut u8,
    line_length: usize,
    options: Base64Options,
) -> usize {
    crate::bindings::simdutfrs_binary_to_base64_with_lines(input, len, output, line_length, options as u64)
}

#[cfg(feature = "base64")]
/// Convert a base64 input to a binary output.
///
/// This function follows the WHATWG forgiving-base64 format, which means that it
/// will ignore any ASCII spaces in the input. You may provide a padded input
/// (with one or two equal signs at the end) or an unpadded input (without any
/// equal signs at the end).
///
/// See https://infra.spec.whatwg.org/#forgiving-base64-decode
///
/// This function will fail in case of invalid input. When last_chunk_options =
/// loose, there are two possible reasons for failure: the input contains a
/// number of base64 characters that when divided by 4, leaves a single remainder
/// character (BASE64_INPUT_REMAINDER), or the input contains a character that is
/// not a valid base64 character (INVALID_BASE64_CHARACTER).
///
/// When the error is INVALID_BASE64_CHARACTER, the count contains the index in the
/// input where the invalid character was found. When the error is
/// BASE64_INPUT_REMAINDER, then the count contains the number of bytes decoded.
///
/// The default option (Base64Options::Default) expects the characters `+` and
/// `/` as part of its alphabet. The URL option (Base64Options::Url) expects the
/// characters `-` and `_` as part of its alphabet.
///
/// The padding (`=`) is validated if present. There may be at most two padding
/// characters at the end of the input. If there are any padding characters, the
/// total number of characters (excluding spaces but including padding
/// characters) must be divisible by four.
///
/// You should call this function with a buffer that is at least
/// maximal_binary_length_from_base64_utf16(input, len) bytes long. If you fail
/// to provide that much space, the function may cause a buffer overflow.
///
/// Advanced users may want to tailor how the last chunk is handled. By default,
/// we use a loose (forgiving) approach but we also support a strict approach
/// as well as a stop_before_partial approach, as per the following proposal:
///
/// https://tc39.es/proposal-arraybuffer-base64/spec/#sec-frombase64
///
/// # Safety
/// + `input` and `output` must be non-null and properly aligned.
/// + `input` must be valid for reads of `len * size_of::<u16>()` bytes.
/// + `output` must be valid for writes of `maximal_binary_length_from_base64_utf16(input, len)` bytes.
/// + The memory regions of `input` and `output` must not overlap.
#[inline]
#[must_use]
pub unsafe fn base64_to_binary_utf16(
    input: *const u16,
    len: usize,
    output: *mut u8,
    options: Base64Options,
    last_chunk_options: LastChunkHandlingOptions,
) -> Result {
    crate::bindings::simdutfrs_base64_to_binary_utf16(input, len, output, options as u64, last_chunk_options as u64)
}

#[cfg(feature = "base64")]
/// Convert a base64 input to a binary output.
///
/// This function follows the WHATWG forgiving-base64 format, which means that it
/// will ignore any ASCII spaces in the input. You may provide a padded input
/// (with one or two equal signs at the end) or an unpadded input (without any
/// equal signs at the end).
///
/// See https://infra.spec.whatwg.org/#forgiving-base64-decode
///
/// This function will fail in case of invalid input. When last_chunk_options =
/// loose, there are three possible reasons for failure: the input contains a
/// number of base64 characters that when divided by 4, leaves a single remainder
/// character (BASE64_INPUT_REMAINDER), the input contains a character that is
/// not a valid base64 character (INVALID_BASE64_CHARACTER), or the output buffer
/// is too small (OUTPUT_BUFFER_TOO_SMALL).
///
/// When OUTPUT_BUFFER_TOO_SMALL, we return both the number of bytes written
/// and the number of units processed, see description of the parameters and
/// returned value.
///
/// When the error is INVALID_BASE64_CHARACTER, the count contains the index in the
/// input where the invalid character was found. When the error is
/// BASE64_INPUT_REMAINDER, then the count contains the number of bytes decoded.
///
/// The default option (Base64Options::Default) expects the characters `+` and
/// `/` as part of its alphabet. The URL option (Base64Options::Url) expects the
/// characters `-` and `_` as part of its alphabet.
///
/// The padding (`=`) is validated if present. There may be at most two padding
/// characters at the end of the input. If there are any padding characters, the
/// total number of characters (excluding spaces but including padding
/// characters) must be divisible by four.
///
/// The INVALID_BASE64_CHARACTER cases are considered fatal and you are expected
/// to discard the output unless the parameter decode_up_to_bad_char is set to
/// true. In that case, the function will decode up to the first invalid
/// character. Extra padding characters ('=') are considered invalid characters.
///
/// Advanced users may want to tailor how the last chunk is handled. By default,
/// we use a loose (forgiving) approach but we also support a strict approach
/// as well as a stop_before_partial approach, as per the following proposal:
///
/// https://tc39.es/proposal-arraybuffer-base64/spec/#sec-frombase64
///
/// # Safety
/// + `input` and `output` must be non-null and properly aligned.
/// + `input` must be valid for reads of `len * size_of::<u8>()` bytes.
/// + `output` must be valid for writes.
/// + `out_len` must point to a valid `usize` that represents the number of bytes
///   that can be written to `output`. Upon return, it is modified to reflect
///   how many bytes were written.
/// + The memory regions of `input` and `output` must not overlap.
#[inline]
#[must_use]
pub unsafe fn base64_to_binary_safe(
    input: *const u8,
    len: usize,
    output: *mut u8,
    out_len: *mut usize,
    options: Base64Options,
    last_chunk_options: LastChunkHandlingOptions,
    decode_up_to_bad_char: bool,
) -> Result {
    crate::bindings::simdutfrs_base64_to_binary_safe(
        input,
        len,
        output,
        out_len,
        options as u64,
        last_chunk_options as u64,
        decode_up_to_bad_char,
    )
}

#[cfg(feature = "base64")]
/// Convert a base64 input to a binary output.
///
/// This function follows the WHATWG forgiving-base64 format, which means that it
/// will ignore any ASCII spaces in the input. You may provide a padded input
/// (with one or two equal signs at the end) or an unpadded input (without any
/// equal signs at the end).
///
/// See https://infra.spec.whatwg.org/#forgiving-base64-decode
///
/// This function will fail in case of invalid input. When last_chunk_options =
/// loose, there are three possible reasons for failure: the input contains a
/// number of base64 characters that when divided by 4, leaves a single remainder
/// character (BASE64_INPUT_REMAINDER), the input contains a character that is
/// not a valid base64 character (INVALID_BASE64_CHARACTER), or the output buffer
/// is too small (OUTPUT_BUFFER_TOO_SMALL).
///
/// When OUTPUT_BUFFER_TOO_SMALL, we return both the number of bytes written
/// and the number of units processed, see description of the parameters and
/// returned value.
///
/// When the error is INVALID_BASE64_CHARACTER, the count contains the index in the
/// input where the invalid character was found. When the error is
/// BASE64_INPUT_REMAINDER, then the count contains the number of bytes decoded.
///
/// The default option (Base64Options::Default) expects the characters `+` and
/// `/` as part of its alphabet. The URL option (Base64Options::Url) expects the
/// characters `-` and `_` as part of its alphabet.
///
/// The padding (`=`) is validated if present. There may be at most two padding
/// characters at the end of the input. If there are any padding characters, the
/// total number of characters (excluding spaces but including padding
/// characters) must be divisible by four.
///
/// The INVALID_BASE64_CHARACTER cases are considered fatal and you are expected
/// to discard the output unless the parameter decode_up_to_bad_char is set to
/// true. In that case, the function will decode up to the first invalid
/// character. Extra padding characters ('=') are considered invalid characters.
///
/// Advanced users may want to tailor how the last chunk is handled. By default,
/// we use a loose (forgiving) approach but we also support a strict approach
/// as well as a stop_before_partial approach, as per the following proposal:
///
/// https://tc39.es/proposal-arraybuffer-base64/spec/#sec-frombase64
///
/// # Safety
/// + `input` and `output` must be non-null and properly aligned.
/// + `input` must be valid for reads of `len * size_of::<u16>()` bytes.
/// + `output` must be valid for writes.
/// + `out_len` must point to a valid `usize` that represents the number of bytes
///   that can be written to `output`. Upon return, it is modified to reflect
///   how many bytes were written.
/// + The memory regions of `input` and `output` must not overlap.
#[inline]
#[must_use]
pub unsafe fn base64_to_binary_safe_utf16(
    input: *const u16,
    len: usize,
    output: *mut u8,
    out_len: *mut usize,
    options: Base64Options,
    last_chunk_options: LastChunkHandlingOptions,
    decode_up_to_bad_char: bool,
) -> Result {
    crate::bindings::simdutfrs_base64_to_binary_safe_utf16(
        input,
        len,
        output,
        out_len,
        options as u64,
        last_chunk_options as u64,
        decode_up_to_bad_char,
    )
}
