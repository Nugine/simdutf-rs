use crate::common::*;
use crate::gen::Codegen;

use std::format as f;

pub fn codegen_cpp(g: &mut Codegen) {
    g.lines([
        "// Auto generated by codegen/src/cpp.rs",
        "#include \"simdutf.cpp\"",
        "#include \"simdutfrs_extra.cpp\"",
        "",
        "extern \"C\" {",
        "",
    ]);

    for_each_validate(|encoding| {
        let ch = map_cpp_char_type(encoding);
        g.ln(f!("bool simdutf_validate_{encoding}(const {ch}* buf, size_t len) {{"));
        g.ln(f!("    return simdutf::validate_{encoding}(buf, len);"));
        g.ln("}");
        g.lf();
    });

    for_each_count(|encoding| {
        let ch = map_cpp_char_type(encoding);
        g.ln(f!("size_t simdutf_count_{encoding}(const {ch}* buf, size_t len) {{"));
        g.ln(f!("    return simdutf::count_{encoding}(buf, len);"));
        g.ln("}");
        g.lf();
    });

    for_each_transcoding_length(|from, to| {
        let from_ch = map_cpp_char_type(from);
        g.ln(f!("size_t simdutf_{to}_length_from_{from}(const {from_ch}* buf, size_t len) {{"));
        g.ln(f!("    return simdutf::{to}_length_from_{from}(buf, len);"));
        g.ln("}");
        g.lf();
    });

    for_each_transcoding_convert(|from, to| {
        let from_ch = map_cpp_char_type(from);
        let to_ch = map_cpp_char_type(to);
        g.ln(f!(
            "size_t simdutf_convert_{from}_to_{to}(const {from_ch}* src, size_t len, {to_ch}* dst) {{"
        ));
        g.ln(f!("    return simdutf::convert_{from}_to_{to}(src, len, dst);"));
        g.ln("}");
        g.lf();
    });

    for_each_transcoding_convert(|from, to| {
        let from_ch = map_cpp_char_type(from);
        let to_ch = map_cpp_char_type(to);
        g.ln(f!(
            "size_t simdutf_convert_valid_{from}_to_{to}(const {from_ch}* src, size_t len, {to_ch}* dst) {{"
        ));
        g.ln(f!("    return simdutf::convert_valid_{from}_to_{to}(src, len, dst);"));
        g.ln("}");
        g.lf();
    });

    g.ln("}");
}

pub fn codegen_rust(g: &mut Codegen) {
    g.lines([
        "// Auto generated by codegen/src/bindings.rs", //
        "extern \"C\" {",
        "",
    ]);

    for_each_validate(|encoding| {
        let ch = map_rs_char_type(encoding);
        g.ln(f!("pub fn simdutf_validate_{encoding}(buf: *const {ch}, len: usize) -> bool;"));
    });
    g.lf();

    for_each_count(|encoding| {
        let ch = map_rs_char_type(encoding);
        g.ln(f!("pub fn simdutf_count_{encoding}(buf: *const {ch}, len: usize) -> usize;"));
    });
    g.lf();

    for_each_transcoding_length(|from, to| {
        let from_ch = map_rs_char_type(from);
        g.ln(f!("pub fn simdutf_{to}_length_from_{from}(buf: *const {from_ch}, len: usize) -> usize;"));
    });
    g.lf();

    for_each_transcoding_convert(|from, to| {
        let from_ch = map_rs_char_type(from);
        let to_ch = map_rs_char_type(to);
        g.ln(f!(
            "pub fn simdutf_convert_{from}_to_{to}(src: *const {from_ch}, len: usize, dst: *mut {to_ch}) -> usize;"
        ));
    });
    g.lf();

    for_each_transcoding_convert(|from, to| {
        let from_ch = map_rs_char_type(from);
        let to_ch = map_rs_char_type(to);
        g.ln(f!(
            "pub fn simdutf_convert_valid_{from}_to_{to}(src: *const {from_ch}, len: usize, dst: *mut {to_ch}) -> usize;"
        ));
    });
    g.lf();

    g.ln("}");
}
