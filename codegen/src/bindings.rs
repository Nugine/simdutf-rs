use crate::common::*;

use codegen_writer::g;
use codegen_writer::glines;

pub fn codegen_cpp() {
    glines![
        "// Auto generated by codegen/src/bindings.rs"
        "#include \"simdutf.cpp\""
        "#include \"simdutfrs_extra.cpp\""
        ""
        "extern \"C\" {"
        ""
    ];

    // Note: Most functions (validate, count, *_length_from_*, convert_*, convert_valid_*) are now
    // provided by upstream simdutf v8.0.0 C API, so we don't need to generate wrappers for them.

    // Note: upstream simdutf v8.0.0 now provides *_with_errors functions that return simdutf_result
    // We provide wrapper functions with simdutfrs_ prefix that return simdutfrs_result_t for Rust compatibility
    for_each_validate(|encoding| {
        let ch = map_cpp_char_type(encoding);
        g!("simdutfrs_result_t simdutfrs_validate_{encoding}_with_errors(const {ch}* buf, size_t len) {{");
        g!("    const simdutf::result ans = simdutf::validate_{encoding}_with_errors(buf, len);");
        g!("    return {{ static_cast<uint32_t>(ans.error), ans.count }};");
        g!("}}");
        g!();
    });

    // Note: upstream simdutf v8.0.0 now provides *_with_errors functions that return simdutf_result
    // We provide wrapper functions with simdutfrs_ prefix that return simdutfrs_result_t for Rust compatibility
    for_each_transcoding_convert(|from, to| {
        if from == "latin1" || (from == "utf32" && to == "latin1") {
            return;
        }
        let from_ch = map_cpp_char_type(from);
        let to_ch = map_cpp_char_type(to);
        g!("simdutfrs_result_t \
            simdutfrs_convert_{from}_to_{to}_with_errors(const {from_ch}* src, size_t len, {to_ch}* dst) {{");
        g!("const simdutf::result ans = \
            simdutf::convert_{from}_to_{to}_with_errors(src, len, dst);");
        g!("    return {{ static_cast<uint32_t>(ans.error), ans.count }};");
        g!("}}");
        g!();
    });

    // Note: convert_valid_* functions are now provided by upstream simdutf v8.0.0
    // so we don't need to generate custom wrappers for them anymore.

    // Custom wrappers for base64 functions to maintain API compatibility
    g!("simdutfrs_result_t simdutfrs_base64_to_binary_safe(const char *input,");
    g!("                                               size_t length, char *output,");
    g!("                                               size_t *outlen,");
    g!("                                               uint64_t options) {{");
    g!("    const simdutf::result res =");
    g!("        simdutf::base64_to_binary_safe(input, length, output, *outlen,");
    g!("            static_cast<simdutf::base64_options>(options));");
    g!("    return {{static_cast<uint32_t>(res.error), res.count}};");
    g!("}}");
    g!();

    g!("size_t simdutfrs_binary_to_base64(const char *input,");
    g!("                        size_t length, char *output,");
    g!("                        uint64_t options) {{");
    g!("    return simdutf::binary_to_base64(");
    g!("       input, length, output, static_cast<simdutf::base64_options>(options));");
    g!("}}");

    g!("}}");
}

pub fn codegen_rust() {
    glines![
        "// Auto generated by codegen/src/bindings.rs"
        ""
        "use crate::extra::Result;"
        ""
        "extern \"C\" {"
        ""
    ];

    for_each_validate(|encoding| {
        let ch = map_rs_char_type(encoding);
        g!("pub fn simdutf_validate_{encoding}(buf: *const {ch}, len: usize) -> bool;");
    });
    g!();

    // Note: upstream simdutf v8.0.0 now provides *_with_errors functions that return simdutf_result
    // We use wrapper functions with simdutfrs_ prefix that return simdutfrs_result_t (which is Result in Rust)
    for_each_validate(|encoding| {
        let ch = map_rs_char_type(encoding);
        g!("pub fn simdutfrs_validate_{encoding}_with_errors\
            (buf: *const {ch}, len: usize) -> Result;");
    });
    g!();

    for_each_count(|encoding| {
        let ch = map_rs_char_type(encoding);
        g!("pub fn simdutf_count_{encoding}(buf: *const {ch}, len: usize) -> usize;");
    });
    g!();

    for_each_transcoding_length(|from, to| {
        if from == "latin1" && to == "utf32" {
            return;
        }
        if is_fixed_length_for_latin1(from, to) {
            g!("pub fn simdutf_{to}_length_from_{from}(len: usize) -> usize;");
            return;
        }
        let from_ch = map_rs_char_type(from);
        g!("pub fn simdutf_{to}_length_from_{from}(buf: *const {from_ch}, len: usize) -> usize;");
    });
    g!();

    for_each_transcoding_convert(|from, to| {
        let from_ch = map_rs_char_type(from);
        let to_ch = map_rs_char_type(to);
        g!("pub fn simdutf_convert_{from}_to_{to}\
            (src: *const {from_ch}, len: usize, dst: *mut {to_ch}) -> usize;");
    });
    g!();

    // Note: upstream simdutf v8.0.0 now provides *_with_errors functions that return simdutf_result
    // We use wrapper functions with simdutfrs_ prefix that return simdutfrs_result_t (which is Result in Rust)
    for_each_transcoding_convert(|from, to| {
        if from == "latin1" || (from == "utf32" && to == "latin1") {
            return;
        }
        let from_ch = map_rs_char_type(from);
        let to_ch = map_rs_char_type(to);
        g!("pub fn simdutfrs_convert_{from}_to_{to}_with_errors\
            (src: *const {from_ch}, len: usize, dst: *mut {to_ch}) -> Result;");
    });
    g!();

    // Note: convert_valid_* functions are now provided by upstream simdutf v8.0.0
    // We declare them as coming from the upstream C API
    for_each_transcoding_convert(|from, to| {
        if from == "latin1" || (from == "utf32" && to == "latin1") {
            return;
        }
        let from_ch = map_rs_char_type(from);
        let to_ch = map_rs_char_type(to);
        g!("pub fn simdutf_convert_valid_{from}_to_{to}\
            (src: *const {from_ch}, len: usize, dst: *mut {to_ch}) -> usize;");
    });
    g!();

    // Custom wrapper functions for base64 to maintain API compatibility
    g!("pub fn simdutfrs_base64_to_binary_safe(
        input: *const u8,
        len: usize,
        output: *mut u8,
        out_len: *mut usize,
        options: u64,
        ) -> Result;");
    g!();

    g!("pub fn simdutfrs_binary_to_base64(
        input: *const u8,
        len: usize,
        output: *mut u8,
        options: u64,
    ) -> usize;");

    g!("}}");
}
