use crate::common::*;

use codegen_writer::g;
use codegen_writer::glines;

pub fn codegen_cpp() {
    glines![
        "// Auto generated by codegen/src/bindings.rs"
        "#include \"simdutf.cpp\""
        "#include \"simdutfrs_extra.cpp\""
        ""
        "extern \"C\" {"
        ""
    ];

    for_each_validate(|encoding| {
        let ch = map_cpp_char_type(encoding);
        g!("bool simdutfrs_validate_{encoding}(const {ch}* buf, size_t len) {{");
        g!("    return simdutf::validate_{encoding}(buf, len);");
        g!("}}");
        g!();
    });

    for_each_validate(|encoding| {
        let ch = map_cpp_char_type(encoding);
        g!("simdutfrs_result_t simdutfrs_validate_{encoding}_with_errors(const {ch}* buf, size_t len) {{");
        g!("    const simdutf::result ans = simdutf::validate_{encoding}_with_errors(buf, len);");
        g!("    return {{ static_cast<uint32_t>(ans.error), ans.count }};");
        g!("}}");
        g!();
    });

    for_each_count(|encoding| {
        let ch = map_cpp_char_type(encoding);
        g!("size_t simdutfrs_count_{encoding}(const {ch}* buf, size_t len) {{");
        g!("    return simdutf::count_{encoding}(buf, len);");
        g!("}}");
        g!();
    });

    for_each_transcoding_length(|from, to| {
        if from == "latin1" && to == "utf32" {
            return;
        }
        if is_fixed_length_for_latin1(from, to) {
            g!("size_t simdutfrs_{to}_length_from_{from}(size_t len) {{");
            g!("    return simdutf::{to}_length_from_{from}(len);");
            g!("}}");
            g!();
            return;
        }
        let from_ch = map_cpp_char_type(from);
        g!("size_t simdutfrs_{to}_length_from_{from}(const {from_ch}* buf, size_t len) {{");
        g!("    return simdutf::{to}_length_from_{from}(buf, len);");
        g!("}}");
        g!();
    });

    for_each_transcoding_convert(|from, to| {
        let from_ch = map_cpp_char_type(from);
        let to_ch = map_cpp_char_type(to);
        g!("size_t simdutfrs_convert_{from}_to_{to}(const {from_ch}* src, size_t len, {to_ch}* dst) {{");
        g!("    return simdutf::convert_{from}_to_{to}(src, len, dst);");
        g!("}}");
        g!();
    });

    for_each_transcoding_convert(|from, to| {
        if from == "latin1" || (from == "utf32" && to == "latin1") {
            return;
        }
        let from_ch = map_cpp_char_type(from);
        let to_ch = map_cpp_char_type(to);
        g!("simdutfrs_result_t \
            simdutfrs_convert_{from}_to_{to}_with_errors(const {from_ch}* src, size_t len, {to_ch}* dst) {{");
        g!("const simdutf::result ans = \
            simdutf::convert_{from}_to_{to}_with_errors(src, len, dst);");
        g!("    return {{ static_cast<uint32_t>(ans.error), ans.count }};");
        g!("}}");
        g!();
    });

    for_each_transcoding_convert(|from, to| {
        if from == "latin1" || (from == "utf32" && to == "latin1") {
            return;
        }
        let from_ch = map_cpp_char_type(from);
        let to_ch = map_cpp_char_type(to);
        g!("size_t simdutfrs_convert_valid_{from}_to_{to}(const {from_ch}* src, size_t len, {to_ch}* dst) {{");
        g!("    return simdutf::convert_valid_{from}_to_{to}(src, len, dst);");
        g!("}}");
        g!();
    });

    for_each_count(|encoding| {
        let ch = map_cpp_char_type(encoding);
        g!("size_t simdutfrs_trim_partial_{encoding}(const {ch}* buf, size_t len) {{");
        g!("    return simdutf::trim_partial_{encoding}(buf, len);");
        g!("}}");
        g!();
    });

    // Base64 functions

    // maximal_binary_length_from_base64 (char* version)
    g!("size_t simdutfrs_maximal_binary_length_from_base64(const char *input,");
    g!("                                               size_t length) {{");
    g!("    return simdutf::maximal_binary_length_from_base64(input, length);");
    g!("}}");
    g!();

    // maximal_binary_length_from_base64 (char16_t* version)
    g!("size_t simdutfrs_maximal_binary_length_from_base64_utf16(const char16_t *input,");
    g!("                                               size_t length) {{");
    g!("    return simdutf::maximal_binary_length_from_base64(input, length);");
    g!("}}");
    g!();

    // base64_to_binary (char* version)
    g!("simdutfrs_result_t simdutfrs_base64_to_binary(const char *input,");
    g!("                                               size_t length, char *output,");
    g!("                                               uint64_t options,");
    g!("                                               uint64_t last_chunk_options) {{");
    g!("    const simdutf::result res =");
    g!("        simdutf::base64_to_binary(input, length, output,");
    g!("            static_cast<simdutf::base64_options>(options),");
    g!("            static_cast<simdutf::last_chunk_handling_options>(last_chunk_options));");
    g!("    return {{static_cast<uint32_t>(res.error), res.count}};");
    g!("}}");
    g!();

    // base64_length_from_binary
    g!("size_t simdutfrs_base64_length_from_binary(size_t length,");
    g!("                                        uint64_t options) {{");
    g!("    return simdutf::base64_length_from_binary(");
    g!("       length, static_cast<simdutf::base64_options>(options));");
    g!("}}");
    g!();

    // base64_length_from_binary_with_lines
    g!("size_t simdutfrs_base64_length_from_binary_with_lines(size_t length,");
    g!("                                        uint64_t options,");
    g!("                                        size_t line_length) {{");
    g!("    return simdutf::base64_length_from_binary_with_lines(");
    g!("       length, static_cast<simdutf::base64_options>(options), line_length);");
    g!("}}");
    g!();

    // binary_to_base64
    g!("size_t simdutfrs_binary_to_base64(const char *input,");
    g!("                        size_t length, char *output,");
    g!("                        uint64_t options) {{");
    g!("    return simdutf::binary_to_base64(");
    g!("       input, length, output, static_cast<simdutf::base64_options>(options));");
    g!("}}");
    g!();

    // binary_to_base64_with_lines
    g!("size_t simdutfrs_binary_to_base64_with_lines(const char *input,");
    g!("                        size_t length, char *output,");
    g!("                        size_t line_length,");
    g!("                        uint64_t options) {{");
    g!("    return simdutf::binary_to_base64_with_lines(");
    g!("       input, length, output, line_length, static_cast<simdutf::base64_options>(options));");
    g!("}}");
    g!();

    // base64_to_binary (char16_t* version)
    g!("simdutfrs_result_t simdutfrs_base64_to_binary_utf16(const char16_t *input,");
    g!("                                               size_t length, char *output,");
    g!("                                               uint64_t options,");
    g!("                                               uint64_t last_chunk_options) {{");
    g!("    const simdutf::result res =");
    g!("        simdutf::base64_to_binary(input, length, output,");
    g!("            static_cast<simdutf::base64_options>(options),");
    g!("            static_cast<simdutf::last_chunk_handling_options>(last_chunk_options));");
    g!("    return {{static_cast<uint32_t>(res.error), res.count}};");
    g!("}}");
    g!();

    // base64_to_binary_safe (char* version)
    g!("simdutfrs_result_t simdutfrs_base64_to_binary_safe(const char *input,");
    g!("                                               size_t length, char *output,");
    g!("                                               size_t *outlen,");
    g!("                                               uint64_t options,");
    g!("                                               uint64_t last_chunk_options,");
    g!("                                               bool decode_up_to_bad_char) {{");
    g!("    const simdutf::result res =");
    g!("        simdutf::base64_to_binary_safe(input, length, output, *outlen,");
    g!("            static_cast<simdutf::base64_options>(options),");
    g!("            static_cast<simdutf::last_chunk_handling_options>(last_chunk_options),");
    g!("            decode_up_to_bad_char);");
    g!("    return {{static_cast<uint32_t>(res.error), res.count}};");
    g!("}}");
    g!();

    // base64_to_binary_safe (char16_t* version)
    g!("simdutfrs_result_t simdutfrs_base64_to_binary_safe_utf16(const char16_t *input,");
    g!("                                               size_t length, char *output,");
    g!("                                               size_t *outlen,");
    g!("                                               uint64_t options,");
    g!("                                               uint64_t last_chunk_options,");
    g!("                                               bool decode_up_to_bad_char) {{");
    g!("    const simdutf::result res =");
    g!("        simdutf::base64_to_binary_safe(input, length, output, *outlen,");
    g!("            static_cast<simdutf::base64_options>(options),");
    g!("            static_cast<simdutf::last_chunk_handling_options>(last_chunk_options),");
    g!("            decode_up_to_bad_char);");
    g!("    return {{static_cast<uint32_t>(res.error), res.count}};");
    g!("}}");
    g!();

    g!("}}");
}

pub fn codegen_rust() {
    glines![
        "// Auto generated by codegen/src/bindings.rs"
        ""
        "use crate::extra::Result;"
        ""
        "extern \"C\" {"
        ""
    ];

    for_each_validate(|encoding| {
        let ch = map_rs_char_type(encoding);
        g!("pub fn simdutfrs_validate_{encoding}(buf: *const {ch}, len: usize) -> bool;");
    });
    g!();

    for_each_validate(|encoding| {
        let ch = map_rs_char_type(encoding);
        g!("pub fn simdutfrs_validate_{encoding}_with_errors\
            (buf: *const {ch}, len: usize) -> Result;");
    });
    g!();

    for_each_count(|encoding| {
        let ch = map_rs_char_type(encoding);
        g!("pub fn simdutfrs_count_{encoding}(buf: *const {ch}, len: usize) -> usize;");
    });
    g!();

    for_each_transcoding_length(|from, to| {
        if from == "latin1" && to == "utf32" {
            return;
        }
        if is_fixed_length_for_latin1(from, to) {
            g!("pub fn simdutfrs_{to}_length_from_{from}(len: usize) -> usize;");
            return;
        }
        let from_ch = map_rs_char_type(from);
        g!("pub fn simdutfrs_{to}_length_from_{from}(buf: *const {from_ch}, len: usize) -> usize;");
    });
    g!();

    for_each_transcoding_convert(|from, to| {
        let from_ch = map_rs_char_type(from);
        let to_ch = map_rs_char_type(to);
        g!("pub fn simdutfrs_convert_{from}_to_{to}\
            (src: *const {from_ch}, len: usize, dst: *mut {to_ch}) -> usize;");
    });
    g!();

    for_each_transcoding_convert(|from, to| {
        if from == "latin1" || (from == "utf32" && to == "latin1") {
            return;
        }
        let from_ch = map_rs_char_type(from);
        let to_ch = map_rs_char_type(to);
        g!("pub fn simdutfrs_convert_{from}_to_{to}_with_errors\
            (src: *const {from_ch}, len: usize, dst: *mut {to_ch}) -> Result;");
    });
    g!();

    for_each_transcoding_convert(|from, to| {
        if from == "latin1" || (from == "utf32" && to == "latin1") {
            return;
        }
        let from_ch = map_rs_char_type(from);
        let to_ch = map_rs_char_type(to);
        g!("pub fn simdutfrs_convert_valid_{from}_to_{to}\
            (src: *const {from_ch}, len: usize, dst: *mut {to_ch}) -> usize;");
    });
    g!();

    for_each_count(|encoding| {
        let ch = map_rs_char_type(encoding);
        g!("pub fn simdutfrs_trim_partial_{encoding}(buf: *const {ch}, len: usize) -> usize;");
    });
    g!();

    // Base64 functions
    // maximal_binary_length_from_base64 (char* version)
    g!("pub fn simdutfrs_maximal_binary_length_from_base64(
        input: *const u8,
        len: usize,
    ) -> usize;");
    g!();

    // maximal_binary_length_from_base64 (char16_t* version)
    g!("pub fn simdutfrs_maximal_binary_length_from_base64_utf16(
        input: *const u16,
        len: usize,
    ) -> usize;");
    g!();

    // base64_to_binary (char* version)
    g!("pub fn simdutfrs_base64_to_binary(
        input: *const u8,
        len: usize,
        output: *mut u8,
        options: u64,
        last_chunk_options: u64,
    ) -> Result;");
    g!();

    // base64_length_from_binary
    g!("pub fn simdutfrs_base64_length_from_binary(
        len: usize,
        options: u64,
    ) -> usize;");
    g!();

    // base64_length_from_binary_with_lines
    g!("pub fn simdutfrs_base64_length_from_binary_with_lines(
        len: usize,
        options: u64,
        line_length: usize,
    ) -> usize;");
    g!();

    // binary_to_base64
    g!("pub fn simdutfrs_binary_to_base64(
        input: *const u8,
        len: usize,
        output: *mut u8,
        options: u64,
    ) -> usize;");
    g!();

    // binary_to_base64_with_lines
    g!("pub fn simdutfrs_binary_to_base64_with_lines(
        input: *const u8,
        len: usize,
        output: *mut u8,
        line_length: usize,
        options: u64,
    ) -> usize;");
    g!();

    // base64_to_binary (char16_t* version)
    g!("pub fn simdutfrs_base64_to_binary_utf16(
        input: *const u16,
        len: usize,
        output: *mut u8,
        options: u64,
        last_chunk_options: u64,
    ) -> Result;");
    g!();

    // base64_to_binary_safe (char* version)
    g!("pub fn simdutfrs_base64_to_binary_safe(
        input: *const u8,
        len: usize,
        output: *mut u8,
        out_len: *mut usize,
        options: u64,
        last_chunk_options: u64,
        decode_up_to_bad_char: bool,
    ) -> Result;");
    g!();

    // base64_to_binary_safe (char16_t* version)
    g!("pub fn simdutfrs_base64_to_binary_safe_utf16(
        input: *const u16,
        len: usize,
        output: *mut u8,
        out_len: *mut usize,
        options: u64,
        last_chunk_options: u64,
        decode_up_to_bad_char: bool,
    ) -> Result;");
    g!();

    g!("}}");
}
