use crate::common::*;

use codegen_writer::g;
use codegen_writer::glines;

pub fn codegen() {
    glines![
        "// Auto generated by codegen/src/api.rs"
        ""
        "use crate::extra::{Result, Base64Options, LastChunkHandlingOptions};"
        ""
    ];

    codegen_validate();
    codegen_count();
    codegen_transcoding_length();
    codegen_transcoding_convert();
    codegen_base64();
}

fn decl_ne_and_bom(encoding: &str) {
    if matches!(encoding, "utf16" | "utf32") {
        g!("/// This function uses native endianness.");
        g!("///");
    }

    if encoding.starts_with("utf16") {
        g!("/// This function is not BOM-aware.");
        g!("///");
    }
}

fn decl_assume(encoding: &str) {
    let doc_name = map_doc_name(encoding);
    g!("/// + The input string must be valid {doc_name}.");
}

fn decl_src_dst(from_encoding: &str, to_encoding: &str) {
    let from_ch_ty = map_rs_char_type(from_encoding);
    let to_ch_ty = map_rs_char_type(to_encoding);
    decl_src_dst_tys(from_ch_ty, to_ch_ty, "src", "dst");
}

fn decl_src_dst_tys(from_ch_ty: &str, to_ch_ty: &str, from_name: &str, to_name: &str) {
    g!("/// + `{from_name}` and `{to_name}` must be non-null and properly aligned.");
    g!("/// + `{from_name}` must be valid for reads of `len * size_of::<{from_ch_ty}>()` bytes");
    g!("/// + `{to_name}` must be valid for writes of `count * size_of::<{to_ch_ty}>()` bytes, \
        where the `count` is the number of code units ([`{to_ch_ty}`]) after successful conversion.");
    g!("/// + The memory regions of `{from_name}` and `{to_name}` must not overlap.");
    // TODO: inplace mode?
}

fn codegen_validate() {
    for_each_validate(|encoding| {
        let ch = map_rs_char_type(encoding);
        let doc_name = map_doc_name(encoding);

        g!("/// Validate the {doc_name} string.");
        g!("///");

        decl_ne_and_bom(encoding);

        g!("/// Returns [`true`] if and only if the string is valid {doc_name}.");

        g!("#[inline]");
        g!("#[must_use]");
        g!("pub fn validate_{encoding}(src: &[{ch}]) -> bool {{");
        g!("let len = src.len();");
        g!("let buf = src.as_ptr();");
        g!("unsafe {{ crate::bindings::simdutf_validate_{encoding}(buf, len) }}");
        g!("}}");
        g!();
    });

    for_each_validate(|encoding| {
        let ch = map_rs_char_type(encoding);
        let doc_name = map_doc_name(encoding);

        g!("/// Validate the {doc_name} string.");
        g!("///");

        decl_ne_and_bom(encoding);

        g!("#[inline]");
        g!("#[must_use]");
        g!("pub fn validate_{encoding}_with_errors(src: &[{ch}]) -> Result {{");
        g!("let len = src.len();");
        g!("let buf = src.as_ptr();");
        g!("unsafe {{ crate::bindings::simdutf_validate_{encoding}_with_errors(buf, len) }}");
        g!("}}");
        g!();
    });
}

fn codegen_count() {
    for_each_count(|encoding| {
        let ch = map_rs_char_type(encoding);
        let doc_name = map_doc_name(encoding);

        g!("/// Count the number of code points in the {doc_name} string.");
        g!("///");

        decl_ne_and_bom(encoding);

        g!("/// This function does not validate the input.");
        g!("/// It is acceptable to pass invalid {doc_name} strings but in such cases the result is implementation defined.");
        g!("///");

        g!("#[inline]");
        g!("#[must_use]");
        g!("pub fn count_{encoding}(src: &[{ch}]) -> usize {{");
        g!("let len = src.len();");
        g!("let buf = src.as_ptr();");
        g!("unsafe{{ crate::bindings::simdutf_count_{encoding}(buf, len) }}");
        g!("}}");
        g!();
    });
}

fn codegen_transcoding_length() {
    for_each_transcoding_length(|from, to| {
        if from == "latin1" && to == "utf32" {
            return;
        }
        let from_ch = map_rs_char_type(from);
        let from_doc_name = map_doc_name(from);
        let to_doc_name = map_doc_name(to);

        g!("/// Count the number of code units that \
             the {from_doc_name} string would require in {to_doc_name} format.");
        g!("///");

        if to == "utf32" {
            g!("/// This function is equivalent to [`count_{from}`].");
            g!("///");
        }

        decl_ne_and_bom(from);

        g!("/// This function does not validate the input.");
        g!("/// It is acceptable to pass invalid {from_doc_name} strings but in such cases the result is implementation defined.");
        g!("///");

        g!("#[inline]");
        g!("#[must_use]");
        if is_fixed_length_for_latin1(from, to) {
            g!("pub fn {to}_length_from_{from}(src_len: usize) -> usize {{");
            g!("    unsafe{{ crate::bindings::simdutf_{to}_length_from_{from}(src_len) }}");
            g!("}}");
        } else {
            g!("pub fn {to}_length_from_{from}(src: &[{from_ch}]) -> usize {{");
            g!("    let len = src.len();");
            g!("    let buf = src.as_ptr();");
            g!("    unsafe{{ crate::bindings::simdutf_{to}_length_from_{from}(buf, len) }}");
            g!("}}");
        }
        g!();
    })
}

fn codegen_transcoding_convert() {
    for_each_transcoding_convert(|from, to| {
        let from_ch = map_rs_char_type(from);
        let to_ch = map_rs_char_type(to);
        let from_doc_name = map_doc_name(from);
        let to_doc_name = map_doc_name(to);

        g!("/// Convert possibly broken {from_doc_name} string into {to_doc_name} string.");
        g!("///");
        g!("/// During the conversion also validation of the input string is done.");
        g!("/// This function is suitable to work with inputs from untrusted sources.");
        g!("///");
        g!("/// Returns the number of written code units; \
            0 if the input is not a valid {from_doc_name} string");
        g!("///");

        decl_ne_and_bom(from);

        g!("/// # Safety");
        decl_src_dst(from, to);

        g!("#[inline]");
        g!("#[must_use]");
        g!("pub unsafe fn convert_{from}_to_{to}\
            (src: *const {from_ch}, len: usize, dst: *mut {to_ch}) -> usize {{");
        g!("crate::bindings::simdutf_convert_{from}_to_{to}(src, len, dst)");
        g!("}}");
        g!();
    });

    for_each_transcoding_convert(|from, to| {
        if from == "latin1" || (from == "utf32" && to == "latin1") {
            return;
        }
        let from_ch = map_rs_char_type(from);
        let to_ch = map_rs_char_type(to);
        let from_doc_name = map_doc_name(from);
        let to_doc_name = map_doc_name(to);

        g!("/// Convert possibly broken {from_doc_name} string into {to_doc_name} string.");
        g!("///");
        g!("/// During the conversion also validation of the input string is done.");
        g!("/// This function is suitable to work with inputs from untrusted sources.");
        g!("///");

        decl_ne_and_bom(from);

        g!("/// # Safety");
        decl_src_dst(from, to);

        g!("#[inline]");
        g!("#[must_use]");
        g!("pub unsafe fn convert_{from}_to_{to}_with_errors\
            (src: *const {from_ch}, len: usize, dst: *mut {to_ch}) -> Result {{");
        g!("crate::bindings::simdutf_convert_{from}_to_{to}_with_errors(src, len, dst)");
        g!("}}");
        g!();
    });

    for_each_transcoding_convert(|from, to| {
        if from == "latin1" || (from == "utf32" && to == "latin1") {
            return;
        }
        let from_ch = map_rs_char_type(from);
        let to_ch = map_rs_char_type(to);
        let from_doc_name = map_doc_name(from);
        let to_doc_name = map_doc_name(to);

        g!("/// Convert valid {from_doc_name} string into {to_doc_name} string.");
        g!("///");
        g!("/// Returns the number of written code units.");
        g!("///");

        decl_ne_and_bom(from);

        g!("/// # Safety");
        decl_assume(from);
        decl_src_dst(from, to);

        g!("#[inline]");
        g!("#[must_use]");
        g!("pub unsafe fn convert_valid_{from}_to_{to}\
            (src: *const {from_ch}, len: usize, dst: *mut {to_ch}) -> usize {{");
        g!("crate::bindings::simdutf_convert_valid_{from}_to_{to}(src, len, dst)");
        g!("}}");
        g!();
    })
}

fn codegen_base64() {
    // Base64 functions

    // maximal_binary_length_from_base64 (char* version)
    g!("/// Provide the maximal binary length in bytes given the base64 input.");
    g!("/// As long as the input does not contain ignorable characters (e.g., ASCII");
    g!("/// spaces or linefeed characters), the result is exact. In particular, the");
    g!("/// function checks for padding characters.");
    g!("///");
    g!("/// The function is fast (constant time). It checks up to two characters at");
    g!("/// the end of the string. The input is not otherwise validated or read.");
    g!("///");
    g!("/// # Safety");
    g!("/// + `input` must be non-null and properly aligned.");
    g!("/// + `input` must be valid for reads of `len * size_of::<u8>()` bytes.");
    g!("#[inline]");
    g!("#[must_use]");
    g!("pub unsafe fn maximal_binary_length_from_base64(");
    g!("    input: *const u8,");
    g!("    len: usize,");
    g!(") -> usize {{");
    g!("    crate::bindings::simdutf_maximal_binary_length_from_base64(input, len)");
    g!("}}");
    g!();

    // maximal_binary_length_from_base64 (char16_t* version)
    g!("/// Provide the maximal binary length in bytes given the base64 input.");
    g!("/// As long as the input does not contain ignorable characters (e.g., ASCII");
    g!("/// spaces or linefeed characters), the result is exact. In particular, the");
    g!("/// function checks for padding characters.");
    g!("///");
    g!("/// The function is fast (constant time). It checks up to two characters at");
    g!("/// the end of the string. The input is not otherwise validated or read.");
    g!("///");
    g!("/// # Safety");
    g!("/// + `input` must be non-null and properly aligned.");
    g!("/// + `input` must be valid for reads of `len * size_of::<u16>()` bytes.");
    g!("#[inline]");
    g!("#[must_use]");
    g!("pub unsafe fn maximal_binary_length_from_base64_utf16(");
    g!("    input: *const u16,");
    g!("    len: usize,");
    g!(") -> usize {{");
    g!("    crate::bindings::simdutf_maximal_binary_length_from_base64_utf16(input, len)");
    g!("}}");
    g!();

    // base64_to_binary (char* version)
    g!("/// Convert a base64 input to a binary output.");
    g!("///");
    g!("/// This function follows the WHATWG forgiving-base64 format, which means that it");
    g!("/// will ignore any ASCII spaces in the input. You may provide a padded input");
    g!("/// (with one or two equal signs at the end) or an unpadded input (without any");
    g!("/// equal signs at the end).");
    g!("///");
    g!("/// See https://infra.spec.whatwg.org/#forgiving-base64-decode");
    g!("///");
    g!("/// This function will fail in case of invalid input. When last_chunk_options =");
    g!("/// loose, there are two possible reasons for failure: the input contains a");
    g!("/// number of base64 characters that when divided by 4, leaves a single remainder");
    g!("/// character (BASE64_INPUT_REMAINDER), or the input contains a character that is");
    g!("/// not a valid base64 character (INVALID_BASE64_CHARACTER).");
    g!("///");
    g!("/// When the error is INVALID_BASE64_CHARACTER, the count contains the index in the");
    g!("/// input where the invalid character was found. When the error is");
    g!("/// BASE64_INPUT_REMAINDER, then the count contains the number of bytes decoded.");
    g!("///");
    g!("/// The default option (Base64Options::Default) expects the characters `+` and");
    g!("/// `/` as part of its alphabet. The URL option (Base64Options::Url) expects the");
    g!("/// characters `-` and `_` as part of its alphabet.");
    g!("///");
    g!("/// The padding (`=`) is validated if present. There may be at most two padding");
    g!("/// characters at the end of the input. If there are any padding characters, the");
    g!("/// total number of characters (excluding spaces but including padding");
    g!("/// characters) must be divisible by four.");
    g!("///");
    g!("/// You should call this function with a buffer that is at least");
    g!("/// maximal_binary_length_from_base64(input, len) bytes long. If you fail to");
    g!("/// provide that much space, the function may cause a buffer overflow.");
    g!("///");
    g!("/// Advanced users may want to tailor how the last chunk is handled. By default,");
    g!("/// we use a loose (forgiving) approach but we also support a strict approach");
    g!("/// as well as a stop_before_partial approach, as per the following proposal:");
    g!("///");
    g!("/// https://tc39.es/proposal-arraybuffer-base64/spec/#sec-frombase64");
    g!("///");
    g!("/// # Safety");
    g!("/// + `input` and `output` must be non-null and properly aligned.");
    g!("/// + `input` must be valid for reads of `len * size_of::<u8>()` bytes.");
    g!("/// + `output` must be valid for writes of `maximal_binary_length_from_base64(input, len)` bytes.");
    g!("/// + The memory regions of `input` and `output` must not overlap.");
    g!("#[inline]");
    g!("#[must_use]");
    g!("pub unsafe fn base64_to_binary(");
    g!("    input: *const u8,");
    g!("    len: usize,");
    g!("    output: *mut u8,");
    g!("    options: Base64Options,");
    g!("    last_chunk_options: LastChunkHandlingOptions,");
    g!(") -> Result {{");
    g!("    crate::bindings::simdutf_base64_to_binary(input, len, output, options as u64, last_chunk_options as u64)");
    g!("}}");
    g!();

    // base64_length_from_binary
    g!("/// Provide the base64 length in bytes given the length of a binary input.");
    g!("///");
    g!("/// The length of the output is the length of the input times 4/3. The output");
    g!("/// buffer should be at least base64_length_from_binary(len) bytes long.");
    g!("///");
    g!("/// The default option (Base64Options::Default) uses the characters `+` and `/`");
    g!("/// as part of its alphabet. Further, it adds padding (`=`) at the end of the");
    g!("/// output to ensure that the output length is a multiple of four.");
    g!("///");
    g!("/// The URL option (Base64Options::Url) uses the characters `-` and `_` as part");
    g!("/// of its alphabet. No padding is added at the end of the output.");
    g!("#[inline]");
    g!("#[must_use]");
    g!("pub fn base64_length_from_binary(");
    g!("    len: usize,");
    g!("    options: Base64Options,");
    g!(") -> usize {{");
    g!("    unsafe {{ crate::bindings::simdutf_base64_length_from_binary(len, options as u64) }}");
    g!("}}");
    g!();

    // base64_length_from_binary_with_lines
    g!("/// Provide the base64 length in bytes given the length of a binary input,");
    g!("/// taking into account line breaks.");
    g!("///");
    g!("/// The length of the output is the length of the input times 4/3. The output");
    g!("/// buffer should be at least base64_length_from_binary_with_lines(len, options,");
    g!("/// line_length) bytes long.");
    g!("///");
    g!("/// The default option (Base64Options::Default) uses the characters `+` and `/`");
    g!("/// as part of its alphabet. Further, it adds padding (`=`) at the end of the");
    g!("/// output to ensure that the output length is a multiple of four.");
    g!("///");
    g!("/// The URL option (Base64Options::Url) uses the characters `-` and `_` as part");
    g!("/// of its alphabet. No padding is added at the end of the output.");
    g!("///");
    g!("/// # Arguments");
    g!("/// * `line_length` - the length of lines, must be at least 4 (otherwise it is");
    g!("///   interpreted as 4).");
    g!("#[inline]");
    g!("#[must_use]");
    g!("pub fn base64_length_from_binary_with_lines(");
    g!("    len: usize,");
    g!("    options: Base64Options,");
    g!("    line_length: usize,");
    g!(") -> usize {{");
    g!("    unsafe {{ crate::bindings::simdutf_base64_length_from_binary_with_lines(len, options as u64, line_length) }}");
    g!("}}");
    g!();

    // binary_to_base64
    g!("/// Convert a binary input to a base64 output.");
    g!("///");
    g!("/// The default option (Base64Options::Default) uses the characters `+` and `/`");
    g!("/// as part of its alphabet. Further, it adds padding (`=`) at the end of the");
    g!("/// output to ensure that the output length is a multiple of four.");
    g!("///");
    g!("/// The URL option (Base64Options::Url) uses the characters `-` and `_` as part");
    g!("/// of its alphabet. No padding is added at the end of the output.");
    g!("///");
    g!("/// This function always succeeds.");
    g!("///");
    g!("/// # Safety");
    g!("/// + `input` and `output` must be non-null and properly aligned.");
    g!("/// + `input` must be valid for reads of `len * size_of::<u8>()` bytes.");
    g!("/// + `output` must be valid for writes of `base64_length_from_binary(len, options)` bytes.");
    g!("/// + The memory regions of `input` and `output` must not overlap.");
    g!("/// + The returned value is the number of written bytes, will be equal to");
    g!("///   `base64_length_from_binary(len, options)`.");
    g!("#[inline]");
    g!("#[must_use]");
    g!("pub unsafe fn binary_to_base64(");
    g!("    input: *const u8,");
    g!("    len: usize,");
    g!("    output: *mut u8,");
    g!("    options: Base64Options,");
    g!(") -> usize {{");
    g!("    crate::bindings::simdutf_binary_to_base64(input, len, output, options as u64)");
    g!("}}");
    g!();

    // binary_to_base64_with_lines
    g!("/// Convert a binary input to a base64 output with line breaks.");
    g!("///");
    g!("/// The default option (Base64Options::Default) uses the characters `+` and `/`");
    g!("/// as part of its alphabet. Further, it adds padding (`=`) at the end of the");
    g!("/// output to ensure that the output length is a multiple of four.");
    g!("///");
    g!("/// The URL option (Base64Options::Url) uses the characters `-` and `_` as part");
    g!("/// of its alphabet. No padding is added at the end of the output.");
    g!("///");
    g!("/// This function always succeeds.");
    g!("///");
    g!("/// # Safety");
    g!("/// + `input` and `output` must be non-null and properly aligned.");
    g!("/// + `input` must be valid for reads of `len * size_of::<u8>()` bytes.");
    g!("/// + `output` must be valid for writes of `base64_length_from_binary_with_lines(len, options, line_length)` bytes.");
    g!("/// + The memory regions of `input` and `output` must not overlap.");
    g!("/// + The returned value is the number of written bytes, will be equal to");
    g!("///   `base64_length_from_binary_with_lines(len, options, line_length)`.");
    g!("///");
    g!("/// # Arguments");
    g!("/// * `line_length` - the length of lines, must be at least 4 (otherwise it is");
    g!("///   interpreted as 4).");
    g!("#[inline]");
    g!("#[must_use]");
    g!("pub unsafe fn binary_to_base64_with_lines(");
    g!("    input: *const u8,");
    g!("    len: usize,");
    g!("    output: *mut u8,");
    g!("    line_length: usize,");
    g!("    options: Base64Options,");
    g!(") -> usize {{");
    g!("    crate::bindings::simdutf_binary_to_base64_with_lines(input, len, output, line_length, options as u64)");
    g!("}}");
    g!();

    // base64_to_binary (char16_t* version)
    g!("/// Convert a base64 input to a binary output.");
    g!("///");
    g!("/// This function follows the WHATWG forgiving-base64 format, which means that it");
    g!("/// will ignore any ASCII spaces in the input. You may provide a padded input");
    g!("/// (with one or two equal signs at the end) or an unpadded input (without any");
    g!("/// equal signs at the end).");
    g!("///");
    g!("/// See https://infra.spec.whatwg.org/#forgiving-base64-decode");
    g!("///");
    g!("/// This function will fail in case of invalid input. When last_chunk_options =");
    g!("/// loose, there are two possible reasons for failure: the input contains a");
    g!("/// number of base64 characters that when divided by 4, leaves a single remainder");
    g!("/// character (BASE64_INPUT_REMAINDER), or the input contains a character that is");
    g!("/// not a valid base64 character (INVALID_BASE64_CHARACTER).");
    g!("///");
    g!("/// When the error is INVALID_BASE64_CHARACTER, the count contains the index in the");
    g!("/// input where the invalid character was found. When the error is");
    g!("/// BASE64_INPUT_REMAINDER, then the count contains the number of bytes decoded.");
    g!("///");
    g!("/// The default option (Base64Options::Default) expects the characters `+` and");
    g!("/// `/` as part of its alphabet. The URL option (Base64Options::Url) expects the");
    g!("/// characters `-` and `_` as part of its alphabet.");
    g!("///");
    g!("/// The padding (`=`) is validated if present. There may be at most two padding");
    g!("/// characters at the end of the input. If there are any padding characters, the");
    g!("/// total number of characters (excluding spaces but including padding");
    g!("/// characters) must be divisible by four.");
    g!("///");
    g!("/// You should call this function with a buffer that is at least");
    g!("/// maximal_binary_length_from_base64_utf16(input, len) bytes long. If you fail");
    g!("/// to provide that much space, the function may cause a buffer overflow.");
    g!("///");
    g!("/// Advanced users may want to tailor how the last chunk is handled. By default,");
    g!("/// we use a loose (forgiving) approach but we also support a strict approach");
    g!("/// as well as a stop_before_partial approach, as per the following proposal:");
    g!("///");
    g!("/// https://tc39.es/proposal-arraybuffer-base64/spec/#sec-frombase64");
    g!("///");
    g!("/// # Safety");
    g!("/// + `input` and `output` must be non-null and properly aligned.");
    g!("/// + `input` must be valid for reads of `len * size_of::<u16>()` bytes.");
    g!("/// + `output` must be valid for writes.");
    g!("/// + The memory regions of `input` and `output` must not overlap.");
    g!("#[inline]");
    g!("#[must_use]");
    g!("pub unsafe fn base64_to_binary_utf16(");
    g!("    input: *const u16,");
    g!("    len: usize,");
    g!("    output: *mut u8,");
    g!("    options: Base64Options,");
    g!("    last_chunk_options: LastChunkHandlingOptions,");
    g!(") -> Result {{");
    g!("    crate::bindings::simdutf_base64_to_binary_utf16(input, len, output, options as u64, last_chunk_options as u64)");
    g!("}}");
    g!();

    // base64_to_binary_safe (char* version)
    g!("/// Convert a base64 input to a binary output.");
    g!("///");
    g!("/// This function follows the WHATWG forgiving-base64 format, which means that it");
    g!("/// will ignore any ASCII spaces in the input. You may provide a padded input");
    g!("/// (with one or two equal signs at the end) or an unpadded input (without any");
    g!("/// equal signs at the end).");
    g!("///");
    g!("/// See https://infra.spec.whatwg.org/#forgiving-base64-decode");
    g!("///");
    g!("/// This function will fail in case of invalid input. When last_chunk_options =");
    g!("/// loose, there are three possible reasons for failure: the input contains a");
    g!("/// number of base64 characters that when divided by 4, leaves a single remainder");
    g!("/// character (BASE64_INPUT_REMAINDER), the input contains a character that is");
    g!("/// not a valid base64 character (INVALID_BASE64_CHARACTER), or the output buffer");
    g!("/// is too small (OUTPUT_BUFFER_TOO_SMALL).");
    g!("///");
    g!("/// When OUTPUT_BUFFER_TOO_SMALL, we return both the number of bytes written");
    g!("/// and the number of units processed, see description of the parameters and");
    g!("/// returned value.");
    g!("///");
    g!("/// When the error is INVALID_BASE64_CHARACTER, the count contains the index in the");
    g!("/// input where the invalid character was found. When the error is");
    g!("/// BASE64_INPUT_REMAINDER, then the count contains the number of bytes decoded.");
    g!("///");
    g!("/// The default option (Base64Options::Default) expects the characters `+` and");
    g!("/// `/` as part of its alphabet. The URL option (Base64Options::Url) expects the");
    g!("/// characters `-` and `_` as part of its alphabet.");
    g!("///");
    g!("/// The padding (`=`) is validated if present. There may be at most two padding");
    g!("/// characters at the end of the input. If there are any padding characters, the");
    g!("/// total number of characters (excluding spaces but including padding");
    g!("/// characters) must be divisible by four.");
    g!("///");
    g!("/// The INVALID_BASE64_CHARACTER cases are considered fatal and you are expected");
    g!("/// to discard the output unless the parameter decode_up_to_bad_char is set to");
    g!("/// true. In that case, the function will decode up to the first invalid");
    g!("/// character. Extra padding characters ('=') are considered invalid characters.");
    g!("///");
    g!("/// Advanced users may want to tailor how the last chunk is handled. By default,");
    g!("/// we use a loose (forgiving) approach but we also support a strict approach");
    g!("/// as well as a stop_before_partial approach, as per the following proposal:");
    g!("///");
    g!("/// https://tc39.es/proposal-arraybuffer-base64/spec/#sec-frombase64");
    g!("///");
    g!("/// # Safety");
    g!("/// + `input` and `output` must be non-null and properly aligned.");
    g!("/// + `input` must be valid for reads of `len * size_of::<u8>()` bytes.");
    g!("/// + `output` must be valid for writes.");
    g!("/// + `out_len` must point to a valid `usize` that represents the number of bytes");
    g!("///   that can be written to `output`. Upon return, it is modified to reflect");
    g!("///   how many bytes were written.");
    g!("/// + The memory regions of `input` and `output` must not overlap.");
    g!("#[inline]");
    g!("#[must_use]");
    g!("pub unsafe fn base64_to_binary_safe(");
    g!("    input: *const u8,");
    g!("    len: usize,");
    g!("    output: *mut u8,");
    g!("    out_len: *mut usize,");
    g!("    options: Base64Options,");
    g!("    last_chunk_options: LastChunkHandlingOptions,");
    g!("    decode_up_to_bad_char: bool,");
    g!(") -> Result {{");
    g!("    crate::bindings::simdutf_base64_to_binary_safe(input, len, output, out_len, options as u64, last_chunk_options as u64, decode_up_to_bad_char)");
    g!("}}");
    g!();

    // base64_to_binary_safe (char16_t* version)
    g!("/// Convert a base64 input to a binary output.");
    g!("///");
    g!("/// This function follows the WHATWG forgiving-base64 format, which means that it");
    g!("/// will ignore any ASCII spaces in the input. You may provide a padded input");
    g!("/// (with one or two equal signs at the end) or an unpadded input (without any");
    g!("/// equal signs at the end).");
    g!("///");
    g!("/// See https://infra.spec.whatwg.org/#forgiving-base64-decode");
    g!("///");
    g!("/// This function will fail in case of invalid input. When last_chunk_options =");
    g!("/// loose, there are three possible reasons for failure: the input contains a");
    g!("/// number of base64 characters that when divided by 4, leaves a single remainder");
    g!("/// character (BASE64_INPUT_REMAINDER), the input contains a character that is");
    g!("/// not a valid base64 character (INVALID_BASE64_CHARACTER), or the output buffer");
    g!("/// is too small (OUTPUT_BUFFER_TOO_SMALL).");
    g!("///");
    g!("/// When OUTPUT_BUFFER_TOO_SMALL, we return both the number of bytes written");
    g!("/// and the number of units processed, see description of the parameters and");
    g!("/// returned value.");
    g!("///");
    g!("/// When the error is INVALID_BASE64_CHARACTER, the count contains the index in the");
    g!("/// input where the invalid character was found. When the error is");
    g!("/// BASE64_INPUT_REMAINDER, then the count contains the number of bytes decoded.");
    g!("///");
    g!("/// The default option (Base64Options::Default) expects the characters `+` and");
    g!("/// `/` as part of its alphabet. The URL option (Base64Options::Url) expects the");
    g!("/// characters `-` and `_` as part of its alphabet.");
    g!("///");
    g!("/// The padding (`=`) is validated if present. There may be at most two padding");
    g!("/// characters at the end of the input. If there are any padding characters, the");
    g!("/// total number of characters (excluding spaces but including padding");
    g!("/// characters) must be divisible by four.");
    g!("///");
    g!("/// The INVALID_BASE64_CHARACTER cases are considered fatal and you are expected");
    g!("/// to discard the output unless the parameter decode_up_to_bad_char is set to");
    g!("/// true. In that case, the function will decode up to the first invalid");
    g!("/// character. Extra padding characters ('=') are considered invalid characters.");
    g!("///");
    g!("/// Advanced users may want to tailor how the last chunk is handled. By default,");
    g!("/// we use a loose (forgiving) approach but we also support a strict approach");
    g!("/// as well as a stop_before_partial approach, as per the following proposal:");
    g!("///");
    g!("/// https://tc39.es/proposal-arraybuffer-base64/spec/#sec-frombase64");
    g!("///");
    g!("/// # Safety");
    g!("/// + `input` and `output` must be non-null and properly aligned.");
    g!("/// + `input` must be valid for reads of `len * size_of::<u16>()` bytes.");
    g!("/// + `output` must be valid for writes.");
    g!("/// + `out_len` must point to a valid `usize` that represents the number of bytes");
    g!("///   that can be written to `output`. Upon return, it is modified to reflect");
    g!("///   how many bytes were written.");
    g!("/// + The memory regions of `input` and `output` must not overlap.");
    g!("#[inline]");
    g!("#[must_use]");
    g!("pub unsafe fn base64_to_binary_safe_utf16(");
    g!("    input: *const u16,");
    g!("    len: usize,");
    g!("    output: *mut u8,");
    g!("    out_len: *mut usize,");
    g!("    options: Base64Options,");
    g!("    last_chunk_options: LastChunkHandlingOptions,");
    g!("    decode_up_to_bad_char: bool,");
    g!(") -> Result {{");
    g!("    crate::bindings::simdutf_base64_to_binary_safe_utf16(input, len, output, out_len, options as u64, last_chunk_options as u64, decode_up_to_bad_char)");
    g!("}}");
    g!();
}
