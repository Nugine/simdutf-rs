// Auto generated by codegen/src/validate.rs

/// Validate the ASCII string.
///
/// Returns [`true`] if and only if the string is valid ASCII.
#[inline]
#[must_use]
pub fn validate_ascii(data: &[u8]) -> bool {
    let len = data.len();
    let buf = data.as_ptr();
    unsafe { crate::bindings::simdutf_validate_ascii(buf, len) }
}

/// Validate the UTF-8 string.
///
/// Returns [`true`] if and only if the string is valid UTF-8.
#[inline]
#[must_use]
pub fn validate_utf8(data: &[u8]) -> bool {
    let len = data.len();
    let buf = data.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf8(buf, len) }
}

/// Validate the UTF-16 string.
///
/// Using native endianness.
///
/// Returns [`true`] if and only if the string is valid UTF-16.
#[inline]
#[must_use]
pub fn validate_utf16(data: &[u16]) -> bool {
    let len = data.len();
    let buf = data.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf16(buf, len) }
}

/// Validate the UTF-16BE string.
///
/// Returns [`true`] if and only if the string is valid UTF-16BE.
#[inline]
#[must_use]
pub fn validate_utf16be(data: &[u16]) -> bool {
    let len = data.len();
    let buf = data.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf16be(buf, len) }
}

/// Validate the UTF-16LE string.
///
/// Returns [`true`] if and only if the string is valid UTF-16LE.
#[inline]
#[must_use]
pub fn validate_utf16le(data: &[u16]) -> bool {
    let len = data.len();
    let buf = data.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf16le(buf, len) }
}

/// Validate the UTF-32 string.
///
/// Returns [`true`] if and only if the string is valid UTF-32.
#[inline]
#[must_use]
pub fn validate_utf32(data: &[u32]) -> bool {
    let len = data.len();
    let buf = data.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf32(buf, len) }
}
