// Auto generated by codegen/src/api.rs

use crate::extra::{Base64Options, Result};

/// Validate the ASCII string.
///
/// Returns [`true`] if and only if the string is valid ASCII.
#[inline]
#[must_use]
pub fn validate_ascii(src: &[u8]) -> bool {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutf_validate_ascii(buf, len) }
}

/// Validate the UTF-8 string.
///
/// Returns [`true`] if and only if the string is valid UTF-8.
#[inline]
#[must_use]
pub fn validate_utf8(src: &[u8]) -> bool {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf8(buf, len) }
}

/// Validate the UTF-16 string.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// Returns [`true`] if and only if the string is valid UTF-16.
#[inline]
#[must_use]
pub fn validate_utf16(src: &[u16]) -> bool {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf16(buf, len) }
}

/// Validate the UTF-16BE string.
///
/// This function is not BOM-aware.
///
/// Returns [`true`] if and only if the string is valid UTF-16BE.
#[inline]
#[must_use]
pub fn validate_utf16be(src: &[u16]) -> bool {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf16be(buf, len) }
}

/// Validate the UTF-16LE string.
///
/// This function is not BOM-aware.
///
/// Returns [`true`] if and only if the string is valid UTF-16LE.
#[inline]
#[must_use]
pub fn validate_utf16le(src: &[u16]) -> bool {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf16le(buf, len) }
}

/// Validate the UTF-32 string.
///
/// This function uses native endianness.
///
/// Returns [`true`] if and only if the string is valid UTF-32.
#[inline]
#[must_use]
pub fn validate_utf32(src: &[u32]) -> bool {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf32(buf, len) }
}

/// Validate the ASCII string.
///
#[inline]
#[must_use]
pub fn validate_ascii_with_errors(src: &[u8]) -> Result {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutf_validate_ascii_with_errors(buf, len) }
}

/// Validate the UTF-8 string.
///
#[inline]
#[must_use]
pub fn validate_utf8_with_errors(src: &[u8]) -> Result {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf8_with_errors(buf, len) }
}

/// Validate the UTF-16 string.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
#[inline]
#[must_use]
pub fn validate_utf16_with_errors(src: &[u16]) -> Result {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf16_with_errors(buf, len) }
}

/// Validate the UTF-16BE string.
///
/// This function is not BOM-aware.
///
#[inline]
#[must_use]
pub fn validate_utf16be_with_errors(src: &[u16]) -> Result {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf16be_with_errors(buf, len) }
}

/// Validate the UTF-16LE string.
///
/// This function is not BOM-aware.
///
#[inline]
#[must_use]
pub fn validate_utf16le_with_errors(src: &[u16]) -> Result {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf16le_with_errors(buf, len) }
}

/// Validate the UTF-32 string.
///
/// This function uses native endianness.
///
#[inline]
#[must_use]
pub fn validate_utf32_with_errors(src: &[u32]) -> Result {
    let len = src.len();
    let buf = src.as_ptr();
    unsafe { crate::bindings::simdutf_validate_utf32_with_errors(buf, len) }
}

/// Count the number of code points in the UTF-8 string.
///
/// # Safety
/// + The input string must be valid UTF-8.
#[inline]
#[must_use]
pub unsafe fn count_utf8(src: &[u8]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_count_utf8(buf, len)
}

/// Count the number of code points in the UTF-16 string.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16.
#[inline]
#[must_use]
pub unsafe fn count_utf16(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_count_utf16(buf, len)
}

/// Count the number of code points in the UTF-16BE string.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16BE.
#[inline]
#[must_use]
pub unsafe fn count_utf16be(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_count_utf16be(buf, len)
}

/// Count the number of code points in the UTF-16LE string.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16LE.
#[inline]
#[must_use]
pub unsafe fn count_utf16le(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_count_utf16le(buf, len)
}

/// Count the number of code units that the UTF-16 string would require in UTF-8 format.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16.
#[inline]
#[must_use]
pub unsafe fn utf8_length_from_utf16(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_utf8_length_from_utf16(buf, len)
}

/// Count the number of code units that the UTF-16BE string would require in UTF-8 format.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16BE.
#[inline]
#[must_use]
pub unsafe fn utf8_length_from_utf16be(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_utf8_length_from_utf16be(buf, len)
}

/// Count the number of code units that the UTF-16LE string would require in UTF-8 format.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16LE.
#[inline]
#[must_use]
pub unsafe fn utf8_length_from_utf16le(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_utf8_length_from_utf16le(buf, len)
}

/// Count the number of code units that the UTF-32 string would require in UTF-8 format.
///
/// This function uses native endianness.
///
/// # Safety
/// + The input string must be valid UTF-32.
#[inline]
#[must_use]
pub unsafe fn utf8_length_from_utf32(src: &[u32]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_utf8_length_from_utf32(buf, len)
}

/// Count the number of code units that the Latin1 string would require in UTF-8 format.
///
/// # Safety
/// + The input string must be valid Latin1.
#[inline]
#[must_use]
pub unsafe fn utf8_length_from_latin1(src: &[u8]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_utf8_length_from_latin1(buf, len)
}

/// Count the number of code units that the UTF-8 string would require in UTF-16 format.
///
/// # Safety
/// + The input string must be valid UTF-8.
#[inline]
#[must_use]
pub unsafe fn utf16_length_from_utf8(src: &[u8]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_utf16_length_from_utf8(buf, len)
}

/// Count the number of code units that the UTF-32 string would require in UTF-16 format.
///
/// This function uses native endianness.
///
/// # Safety
/// + The input string must be valid UTF-32.
#[inline]
#[must_use]
pub unsafe fn utf16_length_from_utf32(src: &[u32]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_utf16_length_from_utf32(buf, len)
}

/// Count the number of code units that the Latin1 string would require in UTF-16 format.
///
/// # Safety
/// + The input string must be valid Latin1.
#[inline]
#[must_use]
pub unsafe fn utf16_length_from_latin1(src: &[u8]) -> usize {
    let len = src.len();
    crate::bindings::simdutf_utf16_length_from_latin1(len)
}

/// Count the number of code units that the UTF-8 string would require in UTF-32 format.
///
/// This function is equivalent to [`count_utf8`].
///
/// # Safety
/// + The input string must be valid UTF-8.
#[inline]
#[must_use]
pub unsafe fn utf32_length_from_utf8(src: &[u8]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_utf32_length_from_utf8(buf, len)
}

/// Count the number of code units that the UTF-16 string would require in UTF-32 format.
///
/// This function is equivalent to [`count_utf16`].
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16.
#[inline]
#[must_use]
pub unsafe fn utf32_length_from_utf16(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_utf32_length_from_utf16(buf, len)
}

/// Count the number of code units that the UTF-16BE string would require in UTF-32 format.
///
/// This function is equivalent to [`count_utf16be`].
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16BE.
#[inline]
#[must_use]
pub unsafe fn utf32_length_from_utf16be(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_utf32_length_from_utf16be(buf, len)
}

/// Count the number of code units that the UTF-16LE string would require in UTF-32 format.
///
/// This function is equivalent to [`count_utf16le`].
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16LE.
#[inline]
#[must_use]
pub unsafe fn utf32_length_from_utf16le(src: &[u16]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_utf32_length_from_utf16le(buf, len)
}

/// Count the number of code units that the UTF-8 string would require in Latin1 format.
///
/// # Safety
/// + The input string must be valid UTF-8.
#[inline]
#[must_use]
pub unsafe fn latin1_length_from_utf8(src: &[u8]) -> usize {
    let len = src.len();
    let buf = src.as_ptr();
    crate::bindings::simdutf_latin1_length_from_utf8(buf, len)
}

/// Count the number of code units that the UTF-16 string would require in Latin1 format.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16.
#[inline]
#[must_use]
pub unsafe fn latin1_length_from_utf16(src: &[u16]) -> usize {
    let len = src.len();
    crate::bindings::simdutf_latin1_length_from_utf16(len)
}

/// Count the number of code units that the UTF-32 string would require in Latin1 format.
///
/// This function uses native endianness.
///
/// # Safety
/// + The input string must be valid UTF-32.
#[inline]
#[must_use]
pub unsafe fn latin1_length_from_utf32(src: &[u32]) -> usize {
    let len = src.len();
    crate::bindings::simdutf_latin1_length_from_utf32(len)
}

/// Convert possibly broken UTF-8 string into UTF-16 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-8 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf16(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_utf8_to_utf16(src, len, dst)
}

/// Convert possibly broken UTF-8 string into UTF-16BE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-8 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf16be(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_utf8_to_utf16be(src, len, dst)
}

/// Convert possibly broken UTF-8 string into UTF-16LE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-8 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf16le(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_utf8_to_utf16le(src, len, dst)
}

/// Convert possibly broken UTF-8 string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-8 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf32(src: *const u8, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutf_convert_utf8_to_utf32(src, len, dst)
}

/// Convert possibly broken UTF-8 string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-8 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_latin1(src: *const u8, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_utf8_to_latin1(src, len, dst)
}

/// Convert possibly broken UTF-16 string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16 string
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16_to_utf8(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_utf16_to_utf8(src, len, dst)
}

/// Convert possibly broken UTF-16 string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16 string
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16_to_utf32(src: *const u16, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutf_convert_utf16_to_utf32(src, len, dst)
}

/// Convert possibly broken UTF-16 string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16 string
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16_to_latin1(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_utf16_to_latin1(src, len, dst)
}

/// Convert possibly broken UTF-16BE string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16BE string
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16be_to_utf8(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_utf16be_to_utf8(src, len, dst)
}

/// Convert possibly broken UTF-16BE string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16BE string
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16be_to_utf32(src: *const u16, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutf_convert_utf16be_to_utf32(src, len, dst)
}

/// Convert possibly broken UTF-16BE string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16BE string
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16be_to_latin1(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_utf16be_to_latin1(src, len, dst)
}

/// Convert possibly broken UTF-16LE string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16LE string
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16le_to_utf8(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_utf16le_to_utf8(src, len, dst)
}

/// Convert possibly broken UTF-16LE string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16LE string
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16le_to_utf32(src: *const u16, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutf_convert_utf16le_to_utf32(src, len, dst)
}

/// Convert possibly broken UTF-16LE string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-16LE string
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16le_to_latin1(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_utf16le_to_latin1(src, len, dst)
}

/// Convert possibly broken UTF-32 string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-32 string
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf8(src: *const u32, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_utf32_to_utf8(src, len, dst)
}

/// Convert possibly broken UTF-32 string into UTF-16 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-32 string
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf16(src: *const u32, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_utf32_to_utf16(src, len, dst)
}

/// Convert possibly broken UTF-32 string into UTF-16BE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-32 string
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf16be(src: *const u32, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_utf32_to_utf16be(src, len, dst)
}

/// Convert possibly broken UTF-32 string into UTF-16LE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-32 string
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf16le(src: *const u32, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_utf32_to_utf16le(src, len, dst)
}

/// Convert possibly broken UTF-32 string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid UTF-32 string
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_latin1(src: *const u32, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_utf32_to_latin1(src, len, dst)
}

/// Convert possibly broken Latin1 string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid Latin1 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_latin1_to_utf8(src: *const u8, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_latin1_to_utf8(src, len, dst)
}

/// Convert possibly broken Latin1 string into UTF-16 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid Latin1 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_latin1_to_utf16(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_latin1_to_utf16(src, len, dst)
}

/// Convert possibly broken Latin1 string into UTF-16BE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid Latin1 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_latin1_to_utf16be(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_latin1_to_utf16be(src, len, dst)
}

/// Convert possibly broken Latin1 string into UTF-16LE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid Latin1 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_latin1_to_utf16le(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_latin1_to_utf16le(src, len, dst)
}

/// Convert possibly broken Latin1 string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// Returns the number of written code units; 0 if the input is not a valid Latin1 string
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_latin1_to_utf32(src: *const u8, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutf_convert_latin1_to_utf32(src, len, dst)
}

/// Convert possibly broken UTF-8 string into UTF-16 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf16_with_errors(src: *const u8, len: usize, dst: *mut u16) -> Result {
    crate::bindings::simdutf_convert_utf8_to_utf16_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-8 string into UTF-16BE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf16be_with_errors(src: *const u8, len: usize, dst: *mut u16) -> Result {
    crate::bindings::simdutf_convert_utf8_to_utf16be_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-8 string into UTF-16LE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf16le_with_errors(src: *const u8, len: usize, dst: *mut u16) -> Result {
    crate::bindings::simdutf_convert_utf8_to_utf16le_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-8 string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_utf32_with_errors(src: *const u8, len: usize, dst: *mut u32) -> Result {
    crate::bindings::simdutf_convert_utf8_to_utf32_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-8 string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf8_to_latin1_with_errors(src: *const u8, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutf_convert_utf8_to_latin1_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-16 string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16_to_utf8_with_errors(src: *const u16, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutf_convert_utf16_to_utf8_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-16 string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16_to_utf32_with_errors(src: *const u16, len: usize, dst: *mut u32) -> Result {
    crate::bindings::simdutf_convert_utf16_to_utf32_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-16 string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16_to_latin1_with_errors(src: *const u16, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutf_convert_utf16_to_latin1_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-16BE string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16be_to_utf8_with_errors(src: *const u16, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutf_convert_utf16be_to_utf8_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-16BE string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16be_to_utf32_with_errors(src: *const u16, len: usize, dst: *mut u32) -> Result {
    crate::bindings::simdutf_convert_utf16be_to_utf32_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-16BE string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16be_to_latin1_with_errors(src: *const u16, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutf_convert_utf16be_to_latin1_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-16LE string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16le_to_utf8_with_errors(src: *const u16, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutf_convert_utf16le_to_utf8_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-16LE string into UTF-32 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16le_to_utf32_with_errors(src: *const u16, len: usize, dst: *mut u32) -> Result {
    crate::bindings::simdutf_convert_utf16le_to_utf32_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-16LE string into Latin1 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf16le_to_latin1_with_errors(src: *const u16, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutf_convert_utf16le_to_latin1_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-32 string into UTF-8 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf8_with_errors(src: *const u32, len: usize, dst: *mut u8) -> Result {
    crate::bindings::simdutf_convert_utf32_to_utf8_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-32 string into UTF-16 string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf16_with_errors(src: *const u32, len: usize, dst: *mut u16) -> Result {
    crate::bindings::simdutf_convert_utf32_to_utf16_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-32 string into UTF-16BE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf16be_with_errors(src: *const u32, len: usize, dst: *mut u16) -> Result {
    crate::bindings::simdutf_convert_utf32_to_utf16be_with_errors(src, len, dst)
}

/// Convert possibly broken UTF-32 string into UTF-16LE string.
///
/// During the conversion also validation of the input string is done.
/// This function is suitable to work with inputs from untrusted sources.
///
/// This function uses native endianness.
///
/// # Safety
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_utf32_to_utf16le_with_errors(src: *const u32, len: usize, dst: *mut u16) -> Result {
    crate::bindings::simdutf_convert_utf32_to_utf16le_with_errors(src, len, dst)
}

/// Convert valid UTF-8 string into UTF-16 string.
///
/// Returns the number of written code units.
///
/// # Safety
/// + The input string must be valid UTF-8.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf8_to_utf16(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_valid_utf8_to_utf16(src, len, dst)
}

/// Convert valid UTF-8 string into UTF-16BE string.
///
/// Returns the number of written code units.
///
/// # Safety
/// + The input string must be valid UTF-8.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf8_to_utf16be(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_valid_utf8_to_utf16be(src, len, dst)
}

/// Convert valid UTF-8 string into UTF-16LE string.
///
/// Returns the number of written code units.
///
/// # Safety
/// + The input string must be valid UTF-8.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf8_to_utf16le(src: *const u8, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_valid_utf8_to_utf16le(src, len, dst)
}

/// Convert valid UTF-8 string into UTF-32 string.
///
/// Returns the number of written code units.
///
/// # Safety
/// + The input string must be valid UTF-8.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf8_to_utf32(src: *const u8, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutf_convert_valid_utf8_to_utf32(src, len, dst)
}

/// Convert valid UTF-8 string into Latin1 string.
///
/// Returns the number of written code units.
///
/// # Safety
/// + The input string must be valid UTF-8.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf8_to_latin1(src: *const u8, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_valid_utf8_to_latin1(src, len, dst)
}

/// Convert valid UTF-16 string into UTF-8 string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16_to_utf8(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_valid_utf16_to_utf8(src, len, dst)
}

/// Convert valid UTF-16 string into UTF-32 string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16_to_utf32(src: *const u16, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutf_convert_valid_utf16_to_utf32(src, len, dst)
}

/// Convert valid UTF-16 string into Latin1 string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16_to_latin1(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_valid_utf16_to_latin1(src, len, dst)
}

/// Convert valid UTF-16BE string into UTF-8 string.
///
/// Returns the number of written code units.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16BE.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16be_to_utf8(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_valid_utf16be_to_utf8(src, len, dst)
}

/// Convert valid UTF-16BE string into UTF-32 string.
///
/// Returns the number of written code units.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16BE.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16be_to_utf32(src: *const u16, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutf_convert_valid_utf16be_to_utf32(src, len, dst)
}

/// Convert valid UTF-16BE string into Latin1 string.
///
/// Returns the number of written code units.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16BE.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16be_to_latin1(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_valid_utf16be_to_latin1(src, len, dst)
}

/// Convert valid UTF-16LE string into UTF-8 string.
///
/// Returns the number of written code units.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16LE.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16le_to_utf8(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_valid_utf16le_to_utf8(src, len, dst)
}

/// Convert valid UTF-16LE string into UTF-32 string.
///
/// Returns the number of written code units.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16LE.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u32>()` bytes, where the `count` is the number of code units ([`u32`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16le_to_utf32(src: *const u16, len: usize, dst: *mut u32) -> usize {
    crate::bindings::simdutf_convert_valid_utf16le_to_utf32(src, len, dst)
}

/// Convert valid UTF-16LE string into Latin1 string.
///
/// Returns the number of written code units.
///
/// This function is not BOM-aware.
///
/// # Safety
/// + The input string must be valid UTF-16LE.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u16>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf16le_to_latin1(src: *const u16, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_valid_utf16le_to_latin1(src, len, dst)
}

/// Convert valid UTF-32 string into UTF-8 string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// # Safety
/// + The input string must be valid UTF-32.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf32_to_utf8(src: *const u32, len: usize, dst: *mut u8) -> usize {
    crate::bindings::simdutf_convert_valid_utf32_to_utf8(src, len, dst)
}

/// Convert valid UTF-32 string into UTF-16 string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// # Safety
/// + The input string must be valid UTF-32.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf32_to_utf16(src: *const u32, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_valid_utf32_to_utf16(src, len, dst)
}

/// Convert valid UTF-32 string into UTF-16BE string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// # Safety
/// + The input string must be valid UTF-32.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf32_to_utf16be(src: *const u32, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_valid_utf32_to_utf16be(src, len, dst)
}

/// Convert valid UTF-32 string into UTF-16LE string.
///
/// Returns the number of written code units.
///
/// This function uses native endianness.
///
/// # Safety
/// + The input string must be valid UTF-32.
/// + `src` and `dst` must be non-null and properly aligned.
/// + `src` must be valid for reads of `len * size_of::<u32>()` bytes
/// + `dst` must be valid for writes of `count * size_of::<u16>()` bytes, where the `count` is the number of code units ([`u16`]) after successful conversion.
/// + The memory regions of `src` and `dst` must not overlap.
#[inline]
#[must_use]
pub unsafe fn convert_valid_utf32_to_utf16le(src: *const u32, len: usize, dst: *mut u16) -> usize {
    crate::bindings::simdutf_convert_valid_utf32_to_utf16le(src, len, dst)
}

/// Convert base64 string into binary data.
///
/// # Safety
/// + `input` and `output` must be non-null and properly aligned.
/// + `input` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `output` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `input` and `output` must not overlap.
#[inline]
#[must_use]
pub unsafe fn base64_to_binary_safe(
    input: *const u8,
    len: usize,
    output: *mut u8,
    out_len: *mut usize,
    options: Base64Options,
) -> Result {
    crate::bindings::simdutf_base64_to_binary_safe(input, len, output, out_len, options as u64)
}

/// Convert binary data into base64.
///
/// # Safety
/// + `input` and `output` must be non-null and properly aligned.
/// + `input` must be valid for reads of `len * size_of::<u8>()` bytes
/// + `output` must be valid for writes of `count * size_of::<u8>()` bytes, where the `count` is the number of code units ([`u8`]) after successful conversion.
/// + The memory regions of `input` and `output` must not overlap.
#[inline]
#[must_use]
pub unsafe fn binary_to_base64(input: *const u8, len: usize, output: *mut u8, options: Base64Options) -> usize {
    crate::bindings::simdutf_binary_to_base64(input, len, output, options as u64)
}
